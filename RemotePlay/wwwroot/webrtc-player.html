<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PlayStation Remote Play - WebRTC Player</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            width: 100%;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.2);
        }

        .header p {
            font-size: 1.1em;
            opacity: 0.9;
        }

        .content {
            padding: 30px;
        }

        .video-container {
            position: relative;
            background: #000;
            border-radius: 10px;
            overflow: hidden;
            margin-bottom: 30px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }

        video {
            width: 100%;
            height: auto;
            display: block;
            min-height: 400px;
        }

        .video-placeholder {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #666;
            text-align: center;
            font-size: 1.2em;
        }

        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 30px;
        }

        .input-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        label {
            font-weight: 600;
            color: #333;
            font-size: 0.9em;
        }

        input[type="text"] {
            padding: 12px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 1em;
            transition: border-color 0.3s;
        }

        input[type="text"]:focus {
            outline: none;
            border-color: #667eea;
        }

        .button-group {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
        }

        button {
            flex: 1;
            min-width: 150px;
            padding: 15px 30px;
            font-size: 1em;
            font-weight: 600;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .btn-success {
            background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
            color: white;
        }

        .btn-success:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(17, 153, 142, 0.4);
        }

        .btn-danger {
            background: linear-gradient(135deg, #eb3349 0%, #f45c43 100%);
            color: white;
        }

        .btn-danger:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(235, 51, 73, 0.4);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
        }

        .status {
            padding: 20px;
            background: #f5f5f5;
            border-radius: 10px;
            margin-bottom: 20px;
        }

        .status-item {
            display: flex;
            justify-content: space-between;
            padding: 10px 0;
            border-bottom: 1px solid #e0e0e0;
        }

        .status-item:last-child {
            border-bottom: none;
        }

        .status-label {
            font-weight: 600;
            color: #666;
        }

        .status-value {
            color: #333;
            font-family: 'Courier New', monospace;
        }

        .status-connected {
            color: #11998e;
            font-weight: 600;
        }

        .status-disconnected {
            color: #eb3349;
            font-weight: 600;
        }

        .logs {
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 20px;
            border-radius: 10px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            max-height: 300px;
            overflow-y: auto;
        }

        .log-entry {
            padding: 5px 0;
            border-bottom: 1px solid #333;
        }

        .log-entry:last-child {
            border-bottom: none;
        }

        .log-info {
            color: #4fc3f7;
        }

        .log-success {
            color: #81c784;
        }

        .log-error {
            color: #e57373;
        }

        .log-warning {
            color: #ffb74d;
        }

        .controller-section {
            padding: 20px;
            background: #f5f5f5;
            border-radius: 10px;
            margin-bottom: 30px;
        }

        .controller-wrapper {
            display: flex;
            flex-direction: column;
            gap: 15px;
            align-items: center;
            max-width: 600px;
            margin: 0 auto;
        }

        .controller-shoulder-row {
            display: flex;
            gap: 10px;
            justify-content: space-between;
            align-items: center;
            width: 100%;
        }

        .controller-center-space {
            flex: 1;
            min-width: 100px;
        }

        .controller-main-area {
            display: flex;
            gap: 40px;
            justify-content: center;
            align-items: center;
            width: 100%;
        }

        .controller-left,
        .controller-right {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .controller-dpad-container {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .controller-dpad {
            display: flex;
            flex-direction: column;
            gap: 5px;
            align-items: center;
        }

        .controller-dpad-row {
            display: flex;
            gap: 5px;
            justify-content: center;
        }

        .controller-face-buttons {
            display: flex;
            flex-direction: column;
            gap: 5px;
            align-items: center;
        }

        .controller-face-row {
            display: flex;
            gap: 5px;
            justify-content: center;
        }

        .controller-function-row {
            display: flex;
            gap: 10px;
            justify-content: center;
            align-items: center;
            width: 100%;
        }

        .controller-btn {
            min-width: 60px;
            height: 60px;
            padding: 10px 20px;
            font-size: 1.2em;
            font-weight: 600;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .controller-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
            border-color: #667eea;
        }

        .controller-btn:active {
            transform: translateY(0);
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
        }

        .controller-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
        }

        .controller-btn-small {
            min-width: 80px;
            height: 44px;
            font-size: 0.9em;
            padding: 8px 15px;
        }

        .controller-btn-shoulder {
            min-width: 70px;
            height: 50px;
            font-size: 0.85em;
            padding: 8px 15px;
            background: linear-gradient(135deg, #8e9eab 0%, #eef2f3 100%);
        }

        .controller-btn-dpad {
            min-width: 50px;
            height: 50px;
            font-size: 1.2em;
            padding: 8px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        .controller-btn-face {
            min-width: 70px;
            height: 70px;
            font-size: 1.5em;
            padding: 10px;
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            border-radius: 50%;
        }

        .controller-btn-function {
            min-width: 90px;
            height: 40px;
            font-size: 0.75em;
            padding: 6px 12px;
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
        }

        @media (max-width: 768px) {
            .header h1 {
                font-size: 1.8em;
            }

            .controls {
                grid-template-columns: 1fr;
            }

            .button-group {
                flex-direction: column;
            }

            button {
                min-width: 100%;
            }

            .controller-btn {
                min-width: 50px;
                height: 50px;
                font-size: 1em;
            }

            .controller-btn-small {
                min-width: 70px;
                height: 40px;
                font-size: 0.8em;
            }

            .controller-main-area {
                flex-direction: column;
                gap: 20px;
            }

            .controller-shoulder-row {
                flex-wrap: wrap;
                justify-content: center;
            }

            .controller-center-space {
                display: none;
            }

            .controller-btn-shoulder {
                min-width: 60px;
                height: 45px;
                font-size: 0.75em;
            }

            .controller-btn-dpad {
                min-width: 45px;
                height: 45px;
                font-size: 1em;
            }

            .controller-btn-face {
                min-width: 60px;
                height: 60px;
                font-size: 1.2em;
            }

            .controller-btn-function {
                min-width: 80px;
                height: 38px;
                font-size: 0.7em;
            }
        }
    </style>
    <!-- SignalR åº“ç”¨äºä½å»¶è¿Ÿæ§åˆ¶å™¨è¾“å…¥ -->
    <script src="https://cdn.jsdelivr.net/npm/@microsoft/signalr@8.0.0/dist/browser/signalr.min.js"></script>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ® PlayStation Remote Play</h1>
            <p>WebRTC å®æ—¶æµåª’ä½“æ’­æ”¾å™¨</p>
        </div>

        <div class="content">
            <div class="controller-section" id="authSection">
                <h3 style="margin-bottom: 15px; color: #333;">ğŸ” èº«ä»½éªŒè¯</h3>
                <div class="input-group">
                    <label for="authTokenInput">JWT Token</label>
                    <div class="url-input-group">
                        <input type="password" id="authTokenInput" placeholder="ç²˜è´´ Bearer Tokenï¼Œæˆ–ç›´æ¥è¾“å…¥ JWT å­—ç¬¦ä¸²">
                        <button class="btn-primary" onclick="saveAuthToken()">ä¿å­˜</button>
                        <button class="btn-danger" onclick="clearAuthToken()">æ¸…é™¤</button>
                    </div>
                    <small id="authTokenStatus" style="color: #666; font-size: 0.85em;">
                        å½“å‰æœªé…ç½® Tokenã€‚
                    </small>
                </div>
            </div>

            <div class="video-container">
                <!-- âœ… ä½å»¶è¿Ÿä¼˜åŒ–ï¼šæ·»åŠ preload="none"å’Œmutedå±æ€§ -->
                <video id="remoteVideo" autoplay playsinline preload="none" 
                       style="object-fit: contain;"></video>
                <div class="video-placeholder" id="placeholder">
                    ç­‰å¾…è¿æ¥...
                </div>
            </div>

            <div class="controller-section">
                <h3 style="margin-bottom: 15px; color: #333;">ğŸ® PS5 æ§åˆ¶å™¨</h3>
                <div style="margin-bottom: 15px; padding: 10px; background: #fff; border-radius: 5px; font-size: 0.9em; color: #666;">
                    <strong>âŒ¨ï¸ é”®ç›˜æ˜ å°„ï¼š</strong>
                    <span style="margin-left: 10px;">WASD/æ–¹å‘é”® = æ–¹å‘é”®</span>
                    <span style="margin-left: 10px;">ç©ºæ ¼ = âœ•</span>
                    <span style="margin-left: 10px;">Enter = â—‹</span>
                    <span style="margin-left: 10px;">Shift = â–¡</span>
                    <span style="margin-left: 10px;">Ctrl = â–³</span>
                    <span style="margin-left: 10px;">Q = L1</span>
                    <span style="margin-left: 10px;">E = R1</span>
                    <span style="margin-left: 10px;">Z = L2</span>
                    <span style="margin-left: 10px;">C = R2</span>
                    <span style="margin-left: 10px;">Tab = OPTIONS</span>
                    <span style="margin-left: 10px;">Backspace = SHARE</span>
                    <span style="margin-left: 10px;">Esc = PS</span>
                </div>
                <div class="controller-wrapper">
                    <!-- è‚©é”®åŒºåŸŸ -->
                    <div class="controller-shoulder-row">
                        <button class="controller-btn controller-btn-shoulder" data-button="L1" title="L1">L1</button>
                        <button class="controller-btn controller-btn-shoulder" data-button="L2" title="L2">L2</button>
                        <div class="controller-center-space"></div>
                        <button class="controller-btn controller-btn-shoulder" data-button="R1" title="R1">R1</button>
                        <button class="controller-btn controller-btn-shoulder" data-button="R2" title="R2">R2</button>
                    </div>
                    
                    <!-- ä¸»è¦æ§åˆ¶åŒºåŸŸ -->
                    <div class="controller-main-area">
                        <!-- å·¦ä¾§ï¼šæ–¹å‘é”® -->
                        <div class="controller-left">
                            <div class="controller-dpad-container">
                                <div class="controller-dpad">
                                    <button class="controller-btn controller-btn-dpad" data-button="UP" title="ä¸Š">â†‘</button>
                                    <div class="controller-dpad-row">
                                        <button class="controller-btn controller-btn-dpad" data-button="LEFT" title="å·¦">â†</button>
                                        <button class="controller-btn controller-btn-dpad" data-button="DOWN" title="ä¸‹">â†“</button>
                                        <button class="controller-btn controller-btn-dpad" data-button="RIGHT" title="å³">â†’</button>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- å³ä¾§ï¼šä¸»è¦æŒ‰é’® -->
                        <div class="controller-right">
                            <div class="controller-face-buttons">
                                <button class="controller-btn controller-btn-face" data-button="TRIANGLE" title="ä¸‰è§’é”®">â–³</button>
                                <div class="controller-face-row">
                                    <button class="controller-btn controller-btn-face" data-button="SQUARE" title="æ–¹å—é”®">â–¡</button>
                                    <button class="controller-btn controller-btn-face" data-button="CROSS" title="å‰é”®">âœ•</button>
                                    <button class="controller-btn controller-btn-face" data-button="CIRCLE" title="åœ†åœˆé”®">â—‹</button>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- åŠŸèƒ½é”®åŒºåŸŸ -->
                    <div class="controller-function-row">
                        <button class="controller-btn controller-btn-function" data-button="OPTIONS" title="é€‰é¡¹">OPTIONS</button>
                        <button class="controller-btn controller-btn-function" data-button="SHARE" title="åˆ†äº«">SHARE</button>
                        <button class="controller-btn controller-btn-function" data-button="PS" title="PS é”®">PS</button>
                    </div>
                </div>
            </div>

            <div class="controls">
                <div class="input-group">
                    <label for="remotePlaySessionId">Host ID æˆ– Session ID</label>
                    <input type="text" id="remotePlaySessionId" placeholder="è¾“å…¥ Host ID æˆ– Session ID">
                    <small style="color: #666; font-size: 0.85em; margin-top: 5px;">
                        æ”¯æŒç›´æ¥è¾“å…¥ Host IDï¼ˆè‡ªåŠ¨åˆ›å»º Sessionï¼‰æˆ–å·²å­˜åœ¨çš„ Session ID
                    </small>
                </div>
            </div>

            <div class="button-group">
                <button class="btn-primary" id="connectBtn" onclick="connect()">
                    ğŸ”— è¿æ¥
                </button>
                <button class="btn-danger" id="disconnectBtn" onclick="disconnect()" disabled>
                    â¹ï¸ æ–­å¼€è¿æ¥
                </button>
            </div>

            <div class="status">
                <h3 style="margin-bottom: 15px; color: #333;">ğŸ“Š è¿æ¥çŠ¶æ€</h3>
                <div class="status-item">
                    <span class="status-label">WebRTC Session ID:</span>
                    <span class="status-value" id="sessionId">-</span>
                </div>
                <div class="status-item">
                    <span class="status-label">è¿æ¥çŠ¶æ€:</span>
                    <span class="status-value status-disconnected" id="connectionState">æœªè¿æ¥</span>
                </div>
                <div class="status-item">
                    <span class="status-label">ICE çŠ¶æ€:</span>
                    <span class="status-value" id="iceState">-</span>
                </div>
                <div class="status-item">
                    <span class="status-label">ä¿¡ä»¤çŠ¶æ€:</span>
                    <span class="status-value" id="signalingState">-</span>
                </div>
            </div>

            <div class="status">
                <h3 style="margin-bottom: 15px; color: #333;">â±ï¸ å»¶æ—¶ç»Ÿè®¡</h3>
                <div class="status-item">
                    <span class="status-label">å½“å‰å»¶è¿Ÿ (ä¸PS5ç”»é¢):</span>
                    <span class="status-value" id="currentLatency" style="font-weight: 600; color: #667eea;">-</span>                    
                </div>
                <div class="status-item">
                    <span class="status-label">WebRTC RTT:</span>
                    <span class="status-value" id="webrtcRtt">-</span>
                </div>
                <div class="status-item">
                    <span class="status-label">è§†é¢‘æ’­æ”¾å»¶è¿Ÿ:</span>
                    <span class="status-value" id="videoPlaybackLatency">-</span>
                </div>
                <div class="status-item">
                    <span class="status-label">æ€»å»¶è¿Ÿ (å¹³å‡):</span>
                    <span class="status-value" id="latencyTotalAvg">-</span>
                </div>
                <div class="status-item">
                    <span class="status-label">æ€»å»¶è¿Ÿ (æœ€å°/æœ€å¤§):</span>
                    <span class="status-value" id="latencyTotalRange">-</span>
                </div>
                <div class="status-item">
                    <span class="status-label">ç½‘ç»œä¼ è¾“ (å¹³å‡):</span>
                    <span class="status-value" id="latencyNetworkAvg">-</span>
                </div>
                <div class="status-item">
                    <span class="status-label">æœåŠ¡å™¨å¤„ç† (å¹³å‡):</span>
                    <span class="status-value" id="latencyServerAvg">-</span>
                </div>
                <div class="status-item">
                    <span class="status-label">æ ·æœ¬æ•°é‡:</span>
                    <span class="status-value" id="latencySampleCount">0</span>
                </div>
            </div>

            <div>
                <h3 style="margin-bottom: 15px; color: #333;">ğŸ“ æ—¥å¿—</h3>
                <div class="logs" id="logs"></div>
            </div>
        </div>
    </div>

    <script>
        const AUTH_STORAGE_KEY = 'remoteplay.authToken';
        let authToken = localStorage.getItem(AUTH_STORAGE_KEY) || '';
        let warnedAuthMissing = false;

        function getAuthToken() {
            return authToken?.trim() || '';
        }

        function setAuthToken(token) {
            authToken = (token || '').trim();
            if (authToken) {
                localStorage.setItem(AUTH_STORAGE_KEY, authToken);
            } else {
                localStorage.removeItem(AUTH_STORAGE_KEY);
            }
            warnedAuthMissing = false;
            updateAuthTokenStatus();
        }

        function updateAuthTokenStatus() {
            const statusEl = document.getElementById('authTokenStatus');
            const inputEl = document.getElementById('authTokenInput');
            if (!statusEl || !inputEl) {
                return;
            }
            if (authToken) {
                statusEl.textContent = `Token å·²ä¿å­˜ï¼ˆé•¿åº¦ ${authToken.length}ï¼‰`;
                statusEl.style.color = '#11998e';
                inputEl.value = authToken;
            } else {
                statusEl.textContent = 'å½“å‰æœªé…ç½® Tokenã€‚';
                statusEl.style.color = '#666';
                inputEl.value = '';
            }
        }

        function saveAuthToken() {
            const input = document.getElementById('authTokenInput');
            setAuthToken(input?.value || '');
            if (authToken) {
                log('âœ… Token å·²ä¿å­˜', 'success');
            } else {
                log('âœ… Token å·²æ¸…ç©º', 'info');
            }
        }

        function clearAuthToken() {
            setAuthToken('');
            log('âœ… Token å·²æ¸…ç©º', 'info');
        }

        function authorizedFetch(url, options = {}) {
            const headers = new Headers(options.headers || {});
            const token = getAuthToken();
            if (token) {
                headers.set('Authorization', `Bearer ${token}`);
                warnedAuthMissing = false;
            } else if (!warnedAuthMissing) {
                log('âš ï¸ å°šæœªè®¾ç½® JWT Tokenï¼Œè¯·åœ¨â€œèº«ä»½éªŒè¯â€ä¸­é…ç½®', 'warning');
                warnedAuthMissing = true;
            }
            return fetch(url, { ...options, headers });
        }

        let peerConnection = null;
        let webrtcSessionId = null;
        let remotePlaySessionId = null; // ä¿å­˜ Remote Play Session IDï¼Œç”¨äºæ§åˆ¶å™¨
        const API_BASE = '/api/webrtc'; // å¸¸é‡ï¼Œä¸åº”ä¿®æ”¹
        
        // SignalR è¿æ¥ï¼ˆç”¨äºä½å»¶è¿Ÿæ§åˆ¶å™¨è¾“å…¥ï¼‰
        let controllerConnection = null;
        let controllerConnected = false;
        let isConnecting = false; // âœ… è¿æ¥é”ï¼Œé˜²æ­¢å¹¶å‘è¿æ¥
        
        // å»¶æ—¶ç»Ÿè®¡
        let latencyStatsInterval = null;
        let currentLatencyInterval = null; // å®æ—¶å»¶è¿Ÿæ›´æ–°é—´éš”
        let currentVideoFrameIndex = 0;
        let currentAudioFrameIndex = 0;
        
        // å®æ—¶å»¶è¿Ÿè®¡ç®—ç›¸å…³
        let lastFrameTime = null; // ä¸Šä¸€å¸§çš„æ—¶é—´æˆ³
        let frameReceiveTimes = []; // æœ€è¿‘å¸§çš„æ¥æ”¶æ—¶é—´ï¼ˆç”¨äºè®¡ç®—å¹³æ»‘å»¶è¿Ÿï¼‰
        const MAX_FRAME_TIMES = 30; // ä¿ç•™æœ€è¿‘30å¸§çš„æ—¶é—´

        function log(message, type = 'info') {
            const logsDiv = document.getElementById('logs');
            const entry = document.createElement('div');
            entry.className = `log-entry log-${type}`;
            const timestamp = new Date().toLocaleTimeString();
            entry.textContent = `[${timestamp}] ${message}`;
            logsDiv.appendChild(entry);
            logsDiv.scrollTop = logsDiv.scrollHeight;
            console.log(`[${type.toUpperCase()}] ${message}`);
        }

        function updateStatus(field, value, isConnected = null) {
            const element = document.getElementById(field);
            if (element) {
                element.textContent = value;
                if (isConnected !== null) {
                    element.className = isConnected ? 'status-value status-connected' : 'status-value status-disconnected';
                }
            }
        }

        // åˆ¤æ–­è¾“å…¥çš„æ˜¯ Host ID è¿˜æ˜¯ Session IDï¼ˆGUID æ ¼å¼ï¼‰
        function isGuid(str) {
            const guidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
            return guidRegex.test(str);
        }

        // ä» Host ID åˆ›å»ºæˆ–è·å– Session
        async function getSessionFromHostId(hostId) {
            try {
                log(`æ­£åœ¨ä» Host ID åˆ›å»º Session: ${hostId}...`, 'info');
                const response = await authorizedFetch(`/api/PlayStation/start-session?hostId=${encodeURIComponent(hostId)}`, {
                    method: 'POST'
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`åˆ›å»º Session å¤±è´¥: ${response.status} ${errorText}`);
                }

                const result = await response.json();
                
                // è°ƒè¯•ï¼šæ‰“å°å®Œæ•´å“åº”
                if (result.data) {
                    log(`ğŸ“‹ API è¿”å›æ•°æ®: ${JSON.stringify(result.data).substring(0, 200)}...`, 'info');
                }
                
                if (!result.success) {
                    throw new Error(result.errorMessage || 'åˆ›å»º Session å¤±è´¥');
                }

                // âš ï¸ ä¿®å¤ï¼šæ£€æŸ¥å¤šç§å¯èƒ½çš„å­—æ®µåï¼ˆId, id, sessionId, session_idï¼‰
                const sessionId = result.data?.Id || result.data?.id || result.data?.sessionId || result.data?.session_id;
                
                if (!sessionId) {
                    // å¦‚æœæ‰¾ä¸åˆ° IDï¼Œå°è¯•ä» data å¯¹è±¡ä¸­æŸ¥æ‰¾ GUID æ ¼å¼çš„å­—æ®µ
                    if (result.data) {
                        for (const key in result.data) {
                            const value = result.data[key];
                            if (typeof value === 'string' && isGuid(value)) {
                                log(`âœ… æ‰¾åˆ° Session ID (å­—æ®µå: ${key}): ${value}`, 'success');
                                return value;
                            }
                        }
                    }
                    
                    // å¦‚æœè¿˜æ˜¯æ‰¾ä¸åˆ°ï¼Œæ‰“å°å®Œæ•´æ•°æ®ä»¥ä¾¿è°ƒè¯•
                    log(`âš ï¸ æ— æ³•æ‰¾åˆ° Session IDï¼Œå®Œæ•´å“åº”: ${JSON.stringify(result)}`, 'warning');
                    throw new Error('Session åˆ›å»ºæˆåŠŸä½†æœªè¿”å› Session ID');
                }

                log(`âœ… Session å·²åˆ›å»º/è·å–: ${sessionId}`, 'success');
                return sessionId;
            } catch (error) {
                log(`âŒ ä» Host ID åˆ›å»º Session å¤±è´¥: ${error.message}`, 'error');
                throw error;
            }
        }

        async function connect() {
            try {
                const inputValue = document.getElementById('remotePlaySessionId').value.trim();
                if (!inputValue) {
                    alert('è¯·è¾“å…¥ Host ID æˆ– Session ID');
                    return;
                }

                document.getElementById('connectBtn').disabled = true;
                log('å¼€å§‹è¿æ¥...', 'info');

                // åˆ¤æ–­è¾“å…¥çš„æ˜¯ Host ID è¿˜æ˜¯ Session ID
                let sessionIdForConnect;
                if (isGuid(inputValue)) {
                    // è¾“å…¥çš„æ˜¯ Session IDï¼ˆGUID æ ¼å¼ï¼‰
                    log(`æ£€æµ‹åˆ° Session ID æ ¼å¼: ${inputValue}`, 'info');
                    sessionIdForConnect = inputValue;
                } else {
                    // è¾“å…¥çš„æ˜¯ Host IDï¼Œéœ€è¦å…ˆåˆ›å»º Session
                    log(`æ£€æµ‹åˆ° Host ID æ ¼å¼: ${inputValue}`, 'info');
                    sessionIdForConnect = await getSessionFromHostId(inputValue);
                }

                // 1. åˆ›å»º Offer
                log('æ­£åœ¨åˆ›å»º WebRTC Offer...', 'info');
                const offerRequestPayload = {};
                if (sessionIdForConnect && isGuid(sessionIdForConnect)) {
                    offerRequestPayload.remotePlaySessionId = sessionIdForConnect;
                }

                const offerResponse = await authorizedFetch(`${API_BASE}/offer`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(offerRequestPayload)
                });

                if (!offerResponse.ok) {
                    throw new Error('åˆ›å»º Offer å¤±è´¥');
                }

                const offerData = await offerResponse.json();
                if (!offerData.success) {
                    throw new Error(offerData.errorMessage || 'åˆ›å»º Offer å¤±è´¥');
                }

                webrtcSessionId = offerData.data.sessionId;
                const offer = {
                    type: 'offer',
                    sdp: offerData.data.sdp
                };

                log(`âœ… Offer å·²åˆ›å»ºï¼ŒSession ID: ${webrtcSessionId}`, 'success');
                updateStatus('sessionId', webrtcSessionId);

                // 2. åˆ›å»º PeerConnectionï¼ˆä¼˜åŒ–ä½å»¶è¿Ÿé…ç½®ï¼‰
                log('æ­£åœ¨åˆ›å»º PeerConnection...', 'info');
                peerConnection = new RTCPeerConnection({
                    iceServers: [
                        { urls: 'stun:stun.l.google.com:19302' }
                    ],
                    // ä½å»¶è¿Ÿä¼˜åŒ–é…ç½®
                    iceCandidatePoolSize: 0, // å‡å°‘å€™é€‰æ± å¤§å°ï¼Œé™ä½å»¶è¿Ÿ
                    bundlePolicy: 'max-bundle', // ä½¿ç”¨ bundle ç­–ç•¥å‡å°‘å»¶è¿Ÿ
                    rtcpMuxPolicy: 'require' // è¦æ±‚ RTCP muxï¼Œå‡å°‘å»¶è¿Ÿ
                });
                
                // è®¾ç½®ä½å»¶è¿Ÿé€‰é¡¹
                if (peerConnection.setConfiguration) {
                    try {
                        const config = peerConnection.getConfiguration();
                        config.iceTransportPolicy = 'all'; // å…è®¸æ‰€æœ‰ICEä¼ è¾“ç±»å‹
                        peerConnection.setConfiguration(config);
                        log('âœ… å·²åº”ç”¨ä½å»¶è¿Ÿé…ç½®', 'success');
                    } catch (e) {
                        log(`âš ï¸ é…ç½®è®¾ç½®å¤±è´¥: ${e.message}`, 'warning');
                    }
                }

                // è®¾ç½®äº‹ä»¶ç›‘å¬
                peerConnection.ontrack = (event) => {
                    log(`ğŸ“º æ”¶åˆ°åª’ä½“è½¨é“: ${event.track.kind}`, 'success');
                    const video = document.getElementById('remoteVideo');
                    if (event.streams && event.streams[0]) {
                        video.srcObject = event.streams[0];
                        document.getElementById('placeholder').style.display = 'none';
                        
                        // âœ… ä½å»¶è¿Ÿä¼˜åŒ–ï¼šä¼˜åŒ–è§†é¢‘æ’­æ”¾è®¾ç½®ï¼ˆé›¶ç¼“å†²æ¨¡å¼ï¼‰
                        if (event.track.kind === 'video') {
                            // è®¾ç½®ä½å»¶è¿Ÿæ’­æ”¾å‚æ•°
                            video.playbackRate = 1.0; // ç¡®ä¿æ­£å¸¸æ’­æ”¾é€Ÿåº¦
                            video.defaultPlaybackRate = 1.0;
                            
                            // âœ… é›¶ç¼“å†²è®¾ç½®ï¼šç¦ç”¨è‡ªåŠ¨ç¼“å†²è¡Œä¸º
                            try {
                                // è®¾ç½®è§†é¢‘å±æ€§ä»¥æœ€å°åŒ–ç¼“å†²
                                video.muted = false; // ç¡®ä¿éŸ³é¢‘æ­£å¸¸ï¼ˆå¦‚æœéœ€è¦ï¼‰
                                
                                // âœ… ä½¿ç”¨ requestVideoFrameCallback è®°å½•æ¯å¸§ï¼ˆä¿ç•™ä½œä¸ºä¸»è¦æ–¹å¼ï¼‰
                                // è¿™ç§æ–¹å¼å¯ä»¥ç¡®ä¿ frameIndex åŒ¹é…ï¼Œè™½ç„¶è®°å½•çš„æ˜¯æ¸²æŸ“æ—¶é—´
                                if ('requestVideoFrameCallback' in video) {
                                    let frameCount = 0;
                                    const onVideoFrame = (now, metadata) => {
                                        frameCount++;
                                        
                                        // âœ… è®°å½•æ¯å¸§çš„æ¥æ”¶æ—¶é—´ï¼ˆç”¨äºå»¶è¿Ÿç»Ÿè®¡ï¼‰
                                        // éœ€è¦ä»æ¸²æŸ“æ—¶é—´ä¸­å‡å»ç¼“å†²å»¶è¿Ÿï¼Œå¾—åˆ°çœŸå®çš„æ¥æ”¶æ—¶é—´
                                        if (webrtcSessionId && frameCount <= 1000) {
                                            // å°† DOMHighResTimeStamp è½¬æ¢ä¸º UTC æ—¶é—´
                                            // now æ˜¯å¸§æ¸²æŸ“çš„æ—¶é—´æˆ³ï¼ˆç›¸å¯¹äºé¡µé¢åŠ è½½çš„é«˜ç²¾åº¦æ—¶é—´ï¼‰
                                            const renderTime = new Date(performance.timeOrigin + now);
                                            
                                            // âœ… å…³é”®ä¿®å¤ï¼šä»æ¸²æŸ“æ—¶é—´ä¸­å‡å»ç¼“å†²å»¶è¿Ÿï¼Œå¾—åˆ°çœŸå®çš„æ¥æ”¶æ—¶é—´
                                            // è¿™æ ·æ‰èƒ½å‡†ç¡®è®¡ç®—ä¸PS5ç”»é¢çš„å»¶è¿Ÿï¼Œè€Œä¸æ˜¯åŒ…å«ç¼“å†²çš„ç´¯ç§¯å»¶è¿Ÿ
                                            let bufferLatency = 0;
                                            if (video.buffered && video.buffered.length > 0) {
                                                const bufferedEnd = video.buffered.end(video.buffered.length - 1);
                                                const currentTime = video.currentTime;
                                                bufferLatency = (bufferedEnd - currentTime) * 1000; // è½¬æ¢ä¸ºæ¯«ç§’
                                                
                                                // é™åˆ¶ç¼“å†²å»¶è¿Ÿçš„æœ€å¤§å€¼ï¼ˆé¿å…å¼‚å¸¸å€¼ï¼‰
                                                if (bufferLatency > 5000) bufferLatency = 0;
                                                if (bufferLatency < 0) bufferLatency = 0;
                                            }
                                            
                                            // æ¥æ”¶æ—¶é—´ = æ¸²æŸ“æ—¶é—´ - ç¼“å†²å»¶è¿Ÿ
                                            // è¿™æ ·å¾—åˆ°çš„æ˜¯æ•°æ®åŒ…å®é™…åˆ°è¾¾å¹¶è§£ç å®Œæˆçš„æ—¶é—´ï¼Œè€Œä¸æ˜¯æ˜¾ç¤ºæ—¶é—´
                                            const receiveTime = new Date(renderTime.getTime() - bufferLatency);
                                            
                                            // ä½¿ç”¨å¸§åºå·ä½œä¸º frameIndexï¼ˆä¸æœåŠ¡å™¨ç«¯åŒæ­¥ï¼‰
                                            recordPacketReceiveTime('video', frameCount, receiveTime);
                                        }
                                        
                                        // âœ… è®°å½•å¸§æ¸²æŸ“æ—¶é—´ç”¨äºå®æ—¶å»¶è¿Ÿè®¡ç®—
                                        const frameTime = performance.now();
                                        frameReceiveTimes.push(frameTime);
                                        if (frameReceiveTimes.length > MAX_FRAME_TIMES) {
                                            frameReceiveTimes.shift(); // ç§»é™¤æœ€æ—§çš„
                                        }
                                        
                                        // æ¯å¸§éƒ½æ£€æŸ¥å¹¶å‡å°‘ç¼“å†²
                                        if (video.buffered && video.buffered.length > 0) {
                                            const bufferedEnd = video.buffered.end(video.buffered.length - 1);
                                            const currentTime = video.currentTime;
                                            const bufferAhead = bufferedEnd - currentTime;
                                            
                                            // å¦‚æœç¼“å†²è¶…è¿‡50msï¼Œç«‹å³è·³è½¬
                                            if (bufferAhead > 0.05 && currentTime > 0.01) {
                                                try {
                                                    video.currentTime = bufferedEnd - 0.01;
                                                } catch (e) {
                                                    // å¿½ç•¥é”™è¯¯
                                                }
                                            }
                                        }
                                        
                                        // ç»§ç»­è¯·æ±‚ä¸‹ä¸€å¸§å›è°ƒ
                                        video.requestVideoFrameCallback(onVideoFrame);
                                    };
                                    video.requestVideoFrameCallback(onVideoFrame);
                                }
                                
                                // 2. ç›‘æ§ç¼“å†²å¹¶ä¸»åŠ¨å‡å°‘å»¶è¿Ÿï¼ˆé›¶ç¼“å†²ç­–ç•¥ï¼‰
                                let lastBufferCheck = 0;
                                const bufferCheckInterval = 50; // æ¯50msæ£€æŸ¥ä¸€æ¬¡ï¼ˆæ›´é¢‘ç¹ï¼‰
                                const maxBufferTime = 0.05; // æœ€å¤§å…è®¸ç¼“å†²æ—¶é—´ï¼š50msï¼ˆæ¥è¿‘é›¶ç¼“å†²ï¼‰
                                
                                const checkBufferAndOptimize = () => {
                                    if (video.buffered && video.buffered.length > 0) {
                                        const bufferedEnd = video.buffered.end(video.buffered.length - 1);
                                        const currentTime = video.currentTime;
                                        const bufferAhead = bufferedEnd - currentTime;
                                        
                                        // âœ… é›¶ç¼“å†²ç­–ç•¥ï¼šå¦‚æœç¼“å†²è¶…è¿‡50msï¼Œç«‹å³è·³è½¬ä»¥å‡å°‘å»¶è¿Ÿ
                                        if (bufferAhead > maxBufferTime && currentTime > 0.01) {
                                            // è·³è½¬åˆ°ç¼“å†²æœ«å°¾ï¼Œåªä¿ç•™æœ€å°ç¼“å†²ï¼ˆ10msï¼‰
                                            const targetTime = bufferedEnd - 0.01; // åªä¿ç•™10msç¼“å†²
                                            if (targetTime > currentTime && targetTime < bufferedEnd) {
                                                try {
                                                    video.currentTime = targetTime;
                                                    if (lastBufferCheck % 20 === 0) {
                                                        log(`âš¡ é›¶ç¼“å†²ä¼˜åŒ–: ${(bufferAhead * 1000).toFixed(0)}ms -> 10ms`, 'info');
                                                    }
                                                } catch (e) {
                                                    // å¿½ç•¥è·³è½¬é”™è¯¯ï¼ˆå¯èƒ½å› ä¸ºç¼“å†²å¤ªå°ï¼‰
                                                }
                                            }
                                        }
                                        
                                        // å®šæœŸè®°å½•ç¼“å†²çŠ¶æ€ï¼ˆæ¯2ç§’ä¸€æ¬¡ï¼‰
                                        if (lastBufferCheck % 40 === 0) {
                                            log(`ğŸ“Š è§†é¢‘ç¼“å†²: ${(bufferAhead * 1000).toFixed(0)}ms`, 'info');
                                        }
                                    }
                                    lastBufferCheck++;
                                };
                                
                                // å¯åŠ¨é«˜é¢‘ç¼“å†²ç›‘æ§ï¼ˆé›¶ç¼“å†²æ¨¡å¼ï¼‰
                                const bufferMonitor = setInterval(checkBufferAndOptimize, bufferCheckInterval);
                                
                                // åœ¨è§†é¢‘ç»“æŸæ—¶æ¸…ç†ç›‘æ§
                                event.track.onended = () => {
                                    clearInterval(bufferMonitor);
                                };
                                
                                // âœ… å·²ç§»é™¤ timeupdate äº‹ä»¶ä¸­çš„å»¶è¿Ÿè®°å½•ï¼ˆä¸å‡†ç¡®ï¼‰
                                // å»¶è¿Ÿè®°å½•ç°åœ¨ä½¿ç”¨ requestVideoFrameCallbackï¼Œæ›´å‡†ç¡®
                                
                                log('âœ… è§†é¢‘è½¨é“å·²è¿æ¥ï¼Œå·²ä¼˜åŒ–ä½å»¶è¿Ÿæ’­æ”¾', 'success');
                            } catch (e) {
                                log(`âš ï¸ è§†é¢‘ä¼˜åŒ–è®¾ç½®å¤±è´¥: ${e.message}`, 'warning');
                            }
                        }
                        
                        if (event.track.kind === 'audio') {
                            // è®°å½•éŸ³é¢‘å¸§æ¥æ”¶æ—¶é—´
                            event.track.onended = () => {
                                // éŸ³é¢‘è½¨é“ç»“æŸ
                            };
                        }
                    }
                };

                peerConnection.onicecandidate = async (event) => {
                    if (event.candidate) {
                        log(`ğŸ§Š å‘é€ ICE Candidate`, 'info');
                        try {
                            // ä½¿ç”¨å½“å‰ä½œç”¨åŸŸçš„ webrtcSessionIdï¼ˆä»å¤–éƒ¨ä½œç”¨åŸŸæ•è·ï¼‰
                            const currentSessionId = webrtcSessionId;
                            if (!currentSessionId) {
                                log(`âš ï¸ æ— æ³•å‘é€ ICE Candidate: sessionId æœªè®¾ç½®`, 'warning');
                                return;
                            }
                            
                            await authorizedFetch(`${API_BASE}/ice`, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({
                                    sessionId: currentSessionId,
                                    candidate: event.candidate.candidate,
                                    sdpMid: event.candidate.sdpMid,
                                    sdpMLineIndex: event.candidate.sdpMLineIndex
                                })
                            });
                        } catch (err) {
                            log(`âŒ å‘é€ ICE Candidate å¤±è´¥: ${err.message}`, 'error');
                        }
                    }
                };

                peerConnection.onconnectionstatechange = () => {
                    const state = peerConnection.connectionState;
                    log(`ğŸ”„ è¿æ¥çŠ¶æ€: ${state}`, 'info');
                    updateStatus('connectionState', state, state === 'connected');
                    
                    if (state === 'connected') {
                        document.getElementById('disconnectBtn').disabled = false;
                    } else if (state === 'failed' || state === 'disconnected' || state === 'closed') {
                        document.getElementById('disconnectBtn').disabled = true;
                        document.getElementById('connectBtn').disabled = false;
                    }
                };

                peerConnection.oniceconnectionstatechange = () => {
                    const state = peerConnection.iceConnectionState;
                    log(`ğŸ§Š ICE çŠ¶æ€: ${state}`, 'info');
                    updateStatus('iceState', state);
                };

                peerConnection.onsignalingstatechange = () => {
                    const state = peerConnection.signalingState;
                    updateStatus('signalingState', state);
                };

                // 3. è®¾ç½®è¿œç«¯ Offer å¹¶åˆ›å»º Answer
                log('æ­£åœ¨è®¾ç½®è¿œç«¯æè¿°...', 'info');
                await peerConnection.setRemoteDescription(offer);

                log('æ­£åœ¨åˆ›å»º Answer...', 'info');
                // åˆ›å»º Answer æ—¶ä½¿ç”¨ä½å»¶è¿Ÿé€‰é¡¹
                const answerOptions = {
                    offerToReceiveAudio: true,
                    offerToReceiveVideo: true
                };
                const answer = await peerConnection.createAnswer(answerOptions);
                
                // ä¼˜åŒ– Answer SDP ä»¥é™ä½å»¶è¿Ÿï¼ˆå¦‚æœå¤±è´¥åˆ™è·³è¿‡ï¼‰
                if (answer.sdp) {
                    try {
                        const optimizedSdp = optimizeSdpForLowLatency(answer.sdp);
                        if (optimizedSdp && optimizedSdp.length > 10) {
                            answer.sdp = optimizedSdp;
                        } else {
                            log('âš ï¸ SDP ä¼˜åŒ–ç»“æœæ— æ•ˆï¼Œä½¿ç”¨åŸå§‹ SDP', 'warning');
                        }
                    } catch (sdpError) {
                        log(`âš ï¸ SDP ä¼˜åŒ–å‡ºé”™: ${sdpError.message}ï¼Œä½¿ç”¨åŸå§‹ SDP`, 'warning');
                        // ç»§ç»­ä½¿ç”¨åŸå§‹ SDP
                    }
                }
                
                try {
                    await peerConnection.setLocalDescription(answer);
                    log('âœ… Answer å·²è®¾ç½®', 'success');
                } catch (descError) {
                    log(`âŒ è®¾ç½®æœ¬åœ°æè¿°å¤±è´¥: ${descError.message}`, 'error');
                    // å¦‚æœè®¾ç½®å¤±è´¥ï¼Œå°è¯•ä½¿ç”¨æœªä¼˜åŒ–çš„ SDP
                    if (answer.sdp) {
                        const originalAnswer = await peerConnection.createAnswer(answerOptions);
                        await peerConnection.setLocalDescription(originalAnswer);
                        log('âœ… ä½¿ç”¨åŸå§‹ Answer é‡è¯•æˆåŠŸ', 'success');
                    } else {
                        throw descError;
                    }
                }

                // 4. å‘é€ Answer
                log('æ­£åœ¨å‘é€ Answer...', 'info');
                const answerResponse = await authorizedFetch(`${API_BASE}/answer`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        sessionId: webrtcSessionId,
                        sdp: answer.sdp,
                        type: 'answer'
                    })
                });

                if (!answerResponse.ok) {
                    throw new Error('å‘é€ Answer å¤±è´¥');
                }

                log('âœ… Answer å·²å‘é€', 'success');

                // 5. è¿æ¥åˆ° Remote Play Session
                // ä¿å­˜ Remote Play Session ID åˆ°å…¨å±€å˜é‡ï¼ˆç”¨äºæ§åˆ¶å™¨ï¼‰
                remotePlaySessionId = sessionIdForConnect;
                
                log(`æ­£åœ¨è¿æ¥åˆ° Remote Play Session: ${sessionIdForConnect}...`, 'info');
                
                // ç¡®ä¿ webrtcSessionId å·²è®¾ç½®
                if (!webrtcSessionId) {
                    throw new Error('WebRTC Session ID æœªè®¾ç½®');
                }
                
                let connectResponse;
                try {
                    connectResponse = await authorizedFetch(
                        `${API_BASE}/connect/${webrtcSessionId}/${sessionIdForConnect}`,
                        { method: 'POST' }
                    );
                } catch (fetchError) {
                    log(`âŒ Fetch é”™è¯¯: ${fetchError.message}`, 'error');
                    throw new Error(`è¿æ¥åˆ° Remote Play Session å¤±è´¥: ${fetchError.message}`);
                }

                if (!connectResponse.ok) {
                    const errorText = await connectResponse.text();
                    log(`âŒ HTTP é”™è¯¯å“åº”: ${errorText}`, 'error');
                    throw new Error(`è¿æ¥åˆ° Remote Play Session å¤±è´¥: ${connectResponse.status} ${connectResponse.statusText}`);
                }

                let connectData;
                try {
                    connectData = await connectResponse.json();
                } catch (jsonError) {
                    log(`âŒ JSON è§£æé”™è¯¯: ${jsonError.message}`, 'error');
                    throw new Error(`è§£æå“åº”å¤±è´¥: ${jsonError.message}`);
                }
                
                if (!connectData.success) {
                    throw new Error(connectData.errorMessage || 'è¿æ¥å¤±è´¥');
                }

                log('âœ… å·²è¿æ¥åˆ° Remote Play Sessionï¼Œç­‰å¾…åª’ä½“æµ...', 'success');
                updateStatus('connectionState', 'ç­‰å¾…è¿æ¥...', false);
                
                // å¯åŠ¨å»¶æ—¶ç»Ÿè®¡æ›´æ–°
                startLatencyStatsUpdate();

                // å»ºç«‹è¿æ¥åè¯·æ±‚å…³é”®å¸§
                await requestKeyframe(webrtcSessionId);
                
                // è¿æ¥ SignalR æ§åˆ¶å™¨ï¼ˆä½å»¶è¿Ÿï¼‰
                await connectControllerSignalR(sessionIdForConnect);
                
                // åˆå§‹åŒ–æ§åˆ¶å™¨æŒ‰é’®ï¼ˆè¿æ¥æˆåŠŸåï¼Œåªåˆå§‹åŒ–ä¸€æ¬¡ï¼‰
                try {
                    initControllerButtons();
                    initKeyboardMapping();
                } catch (initError) {
                    log(`âš ï¸ åˆå§‹åŒ–æ§åˆ¶å™¨å¤±è´¥: ${initError.message}`, 'warning');
                    // ä¸æŠ›å‡ºé”™è¯¯ï¼Œå…è®¸è¿æ¥ç»§ç»­
                }

            } catch (error) {
                // è®°å½•å®Œæ•´çš„é”™è¯¯ä¿¡æ¯ï¼ŒåŒ…æ‹¬å †æ ˆè·Ÿè¸ª
                const errorMessage = error.message || 'æœªçŸ¥é”™è¯¯';
                const errorStack = error.stack || '';
                log(`âŒ è¿æ¥å¤±è´¥: ${errorMessage}`, 'error');
                if (errorStack) {
                    log(`âŒ é”™è¯¯å †æ ˆ: ${errorStack.substring(0, 500)}`, 'error');
                }
                console.error('è¿æ¥é”™è¯¯è¯¦æƒ…:', error);
                document.getElementById('connectBtn').disabled = false;
                if (peerConnection) {
                    peerConnection.close();
                    peerConnection = null;
                }
            }
        }

        async function disconnect() {
            if (peerConnection) {
                peerConnection.close();
                peerConnection = null;
            }

            const video = document.getElementById('remoteVideo');
            video.srcObject = null;
            document.getElementById('placeholder').style.display = 'block';

            updateStatus('sessionId', '-');
            updateStatus('connectionState', 'æœªè¿æ¥', false);
            updateStatus('iceState', '-');
            updateStatus('signalingState', '-');

            document.getElementById('connectBtn').disabled = false;
            document.getElementById('disconnectBtn').disabled = true;

            log('å·²æ–­å¼€è¿æ¥', 'warning');

            // æ¸…ç†æœåŠ¡å™¨ç«¯ä¼šè¯
            if (webrtcSessionId) {
                authorizedFetch(`${API_BASE}/session/${webrtcSessionId}`, {
                    method: 'DELETE'
                }).catch(() => {});
                webrtcSessionId = null;
            }
            
            // æ¸…ç† Remote Play Session ID
            remotePlaySessionId = null;
            
            // æ–­å¼€ SignalR è¿æ¥
            await disconnectControllerSignalR();
            
            // åœæ­¢å»¶æ—¶ç»Ÿè®¡æ›´æ–°
            stopLatencyStatsUpdate();
        }
        
        // è®°å½•æ•°æ®åŒ…æ¥æ”¶æ—¶é—´
        // âœ… ä¿®å¤ï¼šæ”¯æŒä¼ å…¥ç²¾ç¡®çš„æ—¶é—´æˆ³ï¼ˆä» requestVideoFrameCallback è·å–ï¼‰
        async function recordPacketReceiveTime(packetType, frameIndex, receiveTime = null) {
            if (!webrtcSessionId) return;
            
            try {
                // ä½¿ç”¨ä¼ å…¥çš„æ—¶é—´æˆ³ï¼Œå¦‚æœæ²¡æœ‰åˆ™ä½¿ç”¨å½“å‰æ—¶é—´
                const timestamp = receiveTime ? receiveTime.toISOString() : new Date().toISOString();
                
                await authorizedFetch(`${API_BASE}/latency/receive`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        sessionId: webrtcSessionId,
                        packetType: packetType,
                        frameIndex: frameIndex,
                        clientReceiveTime: timestamp
                    })
                });
            } catch (error) {
                // é™é»˜å¤±è´¥ï¼Œä¸å½±å“ä¸»è¦åŠŸèƒ½
                console.debug('è®°å½•æ¥æ”¶æ—¶é—´å¤±è´¥:', error);
            }
        }

        // ä¸»åŠ¨è¯·æ±‚å…³é”®å¸§
        async function requestKeyframe(sessionId) {
            if (!sessionId) {
                return;
            }

            try {
                log(`ğŸ¯ è¯·æ±‚å…³é”®å¸§: ${sessionId}`, 'info');
                const response = await authorizedFetch(`${API_BASE}/session/${sessionId}/keyframe`, {
                    method: 'POST'
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    log(`âŒ è¯·æ±‚å…³é”®å¸§å¤±è´¥: ${response.status} ${errorText}`, 'error');
                    return;
                }

                const result = await response.json().catch(() => null);
                if (result?.success) {
                    log('âœ… å…³é”®å¸§è¯·æ±‚å·²å‘é€', 'success');
                } else {
                    const message = result?.errorMessage || result?.message || 'æœªçŸ¥é”™è¯¯';
                    log(`âš ï¸ å…³é”®å¸§è¯·æ±‚è¿”å›éæˆåŠŸçŠ¶æ€: ${message}`, 'warning');
                }
            } catch (error) {
                log(`âŒ è¯·æ±‚å…³é”®å¸§å‡ºç°å¼‚å¸¸: ${error.message}`, 'error');
            }
        }
        
        // å¼€å§‹å»¶æ—¶ç»Ÿè®¡æ›´æ–°
        function startLatencyStatsUpdate() {
            if (latencyStatsInterval) {
                clearInterval(latencyStatsInterval);
            }
            
            // æ¯2ç§’æ›´æ–°ä¸€æ¬¡å»¶æ—¶ç»Ÿè®¡
            latencyStatsInterval = setInterval(async () => {
                if (!webrtcSessionId) return;
                
                try {
                    const response = await authorizedFetch(`${API_BASE}/latency/${webrtcSessionId}`);
                    if (!response.ok) return;
                    
                    const data = await response.json();
                    if (data.success && data.data) {
                        const stats = data.data;
                        updateLatencyStats(stats);
                        // âœ… æ›´æ–°å½“å‰å»¶è¿Ÿï¼ˆä¸PS5çš„å»¶è¿Ÿï¼‰
                        updateCurrentLatencyFromServer(stats);
                    }
                } catch (error) {
                    // é™é»˜å¤±è´¥
                    console.debug('è·å–å»¶æ—¶ç»Ÿè®¡å¤±è´¥:', error);
                }
            }, 2000);
            
            // âœ… å¼€å§‹å®æ—¶å»¶è¿Ÿè®¡ç®—
            startCurrentLatencyUpdate();
        }
        
        // å¼€å§‹å®æ—¶å»¶è¿Ÿæ›´æ–°
        function startCurrentLatencyUpdate() {
            if (currentLatencyInterval) {
                clearInterval(currentLatencyInterval);
            }
            
            // æ¯100msæ›´æ–°ä¸€æ¬¡å®æ—¶å»¶è¿Ÿï¼ˆæ›´é¢‘ç¹ï¼‰
            currentLatencyInterval = setInterval(() => {
                updateCurrentLatency();
            }, 100);
        }
        
        // æ›´æ–°å®æ—¶å»¶è¿Ÿæ˜¾ç¤º
        function updateCurrentLatency() {
            if (!peerConnection) {
                document.getElementById('currentLatency').textContent = '-';
                document.getElementById('webrtcRtt').textContent = '-';
                document.getElementById('videoPlaybackLatency').textContent = '-';
                return;
            }
            
            // 1. è·å– WebRTC RTT
            updateWebRTCStats();
            
            // 2. è®¡ç®—è§†é¢‘æ’­æ”¾å»¶è¿Ÿ
            updateVideoPlaybackLatency();
            
            // 3. âœ… ä¼˜å…ˆä½¿ç”¨æœåŠ¡å™¨è¿”å›çš„ä¸PS5çš„å»¶è¿Ÿï¼Œå¦‚æœæ²¡æœ‰åˆ™ä½¿ç”¨æœ¬åœ°è®¡ç®—
            if (serverCurrentLatency !== null && serverCurrentLatency > 0) {
                // ä½¿ç”¨æœåŠ¡å™¨è¿”å›çš„å»¶è¿Ÿï¼ˆæ›´å‡†ç¡®ï¼Œåæ˜ ä¸PS5çš„çœŸå®å»¶è¿Ÿï¼‰
                displayCurrentLatency(serverCurrentLatency);
            } else {
                // å¤‡ç”¨æ–¹æ¡ˆï¼šä½¿ç”¨æœ¬åœ°è®¡ç®—çš„å»¶è¿Ÿ
                calculateCurrentLatency();
            }
        }
        
        // è·å– WebRTC ç»Ÿè®¡ä¿¡æ¯ï¼ˆRTTï¼‰
        async function updateWebRTCStats() {
            if (!peerConnection) return;
            
            try {
                const stats = await peerConnection.getStats();
                let rtt = null;
                let jitter = null;
                
                stats.forEach(report => {
                    // æŸ¥æ‰¾ candidate-pair æˆ– transport æŠ¥å‘Šï¼ˆåŒ…å« RTTï¼‰
                    if (report.type === 'candidate-pair' && report.currentRoundTripTime) {
                        rtt = report.currentRoundTripTime * 1000; // è½¬æ¢ä¸ºæ¯«ç§’
                    } else if (report.type === 'transport' && report.currentRoundTripTime) {
                        rtt = report.currentRoundTripTime * 1000;
                    }
                    
                    // æŸ¥æ‰¾è§†é¢‘æ¥æ”¶å™¨ç»Ÿè®¡ï¼ˆåŒ…å« jitterï¼‰
                    if (report.type === 'inbound-rtp' && report.mediaType === 'video') {
                        if (report.jitter !== undefined) {
                            jitter = report.jitter * 1000; // è½¬æ¢ä¸ºæ¯«ç§’
                        }
                    }
                });
                
                if (rtt !== null) {
                    document.getElementById('webrtcRtt').textContent = `${rtt.toFixed(1)} ms`;
                } else {
                    document.getElementById('webrtcRtt').textContent = '-';
                }
            } catch (error) {
                console.debug('è·å– WebRTC ç»Ÿè®¡å¤±è´¥:', error);
                document.getElementById('webrtcRtt').textContent = '-';
            }
        }
        
        // è®¡ç®—è§†é¢‘æ’­æ”¾å»¶è¿Ÿï¼ˆåŸºäºç¼“å†²ï¼‰
        function updateVideoPlaybackLatency() {
            const video = document.getElementById('remoteVideo');
            if (!video || !video.buffered || video.buffered.length === 0) {
                document.getElementById('videoPlaybackLatency').textContent = '-';
                return;
            }
            
            try {
                const bufferedEnd = video.buffered.end(video.buffered.length - 1);
                const currentTime = video.currentTime;
                const bufferAhead = bufferedEnd - currentTime;
                
                // æ’­æ”¾å»¶è¿Ÿ = ç¼“å†²æ—¶é—´
                const playbackLatency = bufferAhead * 1000; // è½¬æ¢ä¸ºæ¯«ç§’
                
                if (playbackLatency >= 0 && playbackLatency < 5000) {
                    document.getElementById('videoPlaybackLatency').textContent = `${playbackLatency.toFixed(1)} ms`;
                } else {
                    document.getElementById('videoPlaybackLatency').textContent = '-';
                }
            } catch (error) {
                document.getElementById('videoPlaybackLatency').textContent = '-';
            }
        }
        
        // âœ… ä»æœåŠ¡å™¨è·å–çš„å½“å‰å»¶è¿Ÿï¼ˆä¸PS5çš„å»¶è¿Ÿï¼‰
        let serverCurrentLatency = null;
        
        // æ›´æ–°æœåŠ¡å™¨è¿”å›çš„å½“å‰å»¶è¿Ÿ
        function updateCurrentLatencyFromServer(stats) {
            if (stats && stats.currentLatency !== undefined && stats.currentLatency > 0) {
                serverCurrentLatency = stats.currentLatency;
                // ç«‹å³æ›´æ–°æ˜¾ç¤º
                displayCurrentLatency(serverCurrentLatency);
            }
        }
        
        // è®¡ç®—ç»¼åˆå½“å‰å»¶è¿Ÿï¼ˆå¤‡ç”¨æ–¹æ¡ˆï¼Œå¦‚æœæœåŠ¡å™¨æ²¡æœ‰è¿”å›å»¶è¿Ÿå€¼ï¼‰
        function calculateCurrentLatency() {
            // âœ… ä¼˜å…ˆä½¿ç”¨æœåŠ¡å™¨è¿”å›çš„ä¸PS5çš„å»¶è¿Ÿ
            if (serverCurrentLatency !== null && serverCurrentLatency > 0) {
                displayCurrentLatency(serverCurrentLatency);
                return;
            }
            
            // å¤‡ç”¨æ–¹æ¡ˆï¼šä½¿ç”¨æœ¬åœ°è®¡ç®—çš„å»¶è¿Ÿ
            const rttText = document.getElementById('webrtcRtt').textContent;
            const playbackLatencyText = document.getElementById('videoPlaybackLatency').textContent;
            
            let rtt = null;
            let playbackLatency = null;
            
            // è§£æ RTT
            if (rttText && rttText !== '-') {
                const rttMatch = rttText.match(/([\d.]+)\s*ms/);
                if (rttMatch) {
                    rtt = parseFloat(rttMatch[1]);
                }
            }
            
            // è§£ææ’­æ”¾å»¶è¿Ÿ
            if (playbackLatencyText && playbackLatencyText !== '-') {
                const latencyMatch = playbackLatencyText.match(/([\d.]+)\s*ms/);
                if (latencyMatch) {
                    playbackLatency = parseFloat(latencyMatch[1]);
                }
            }
            
            // è®¡ç®—ç»¼åˆå»¶è¿Ÿï¼ˆä½¿ç”¨å¸§æ¥æ”¶æ—¶é—´å¦‚æœæœ‰çš„è¯ï¼‰
            let currentLatency = null;
            
            if (frameReceiveTimes.length > 0) {
                // ä½¿ç”¨æœ€è¿‘çš„å¸§æ¥æ”¶æ—¶é—´è®¡ç®—å»¶è¿Ÿ
                const now = performance.now();
                const recentTimes = frameReceiveTimes.slice(-10); // ä½¿ç”¨æœ€è¿‘10å¸§
                if (recentTimes.length > 0) {
                    // ä¼°ç®—å½“å‰å»¶è¿Ÿï¼šæ’­æ”¾å»¶è¿Ÿ + ç½‘ç»œå»¶è¿Ÿçš„ä¸€åŠ
                    if (playbackLatency !== null) {
                        currentLatency = playbackLatency + (rtt !== null ? rtt / 2 : 0);
                    } else if (rtt !== null) {
                        currentLatency = rtt;
                    }
                }
            } else if (playbackLatency !== null) {
                // å¦‚æœæ²¡æœ‰å¸§æ—¶é—´ï¼Œä½¿ç”¨æ’­æ”¾å»¶è¿Ÿ
                currentLatency = playbackLatency + (rtt !== null ? rtt / 2 : 0);
            } else if (rtt !== null) {
                // åªæœ‰ RTT
                currentLatency = rtt;
            }
            
            // æ›´æ–°æ˜¾ç¤º
            if (currentLatency !== null && currentLatency >= 0 && currentLatency < 10000) {
                displayCurrentLatency(currentLatency);
            } else {
                document.getElementById('currentLatency').textContent = '-';
            }
        }
        
        // æ˜¾ç¤ºå½“å‰å»¶è¿Ÿï¼ˆå¸¦é¢œè‰²æ ‡è¯†ï¼‰
        function displayCurrentLatency(latency) {
            if (latency === null || latency < 0 || latency >= 10000) {
                document.getElementById('currentLatency').textContent = '-';
                return;
            }
            
            // æ ¹æ®å»¶è¿Ÿå€¼è®¾ç½®é¢œè‰²
            let color = '#667eea'; // é»˜è®¤è“è‰²
            if (latency < 50) {
                color = '#11998e'; // ç»¿è‰²ï¼ˆä½å»¶è¿Ÿï¼‰
            } else if (latency < 100) {
                color = '#ffb74d'; // æ©™è‰²ï¼ˆä¸­ç­‰å»¶è¿Ÿï¼‰
            } else {
                color = '#eb3349'; // çº¢è‰²ï¼ˆé«˜å»¶è¿Ÿï¼‰
            }
            
            const element = document.getElementById('currentLatency');
            element.textContent = `${latency.toFixed(1)} ms`;
            element.style.color = color;
        }
        
        // åœæ­¢å»¶æ—¶ç»Ÿè®¡æ›´æ–°
        function stopLatencyStatsUpdate() {
            if (latencyStatsInterval) {
                clearInterval(latencyStatsInterval);
                latencyStatsInterval = null;
            }
            
            // âœ… åœæ­¢å®æ—¶å»¶è¿Ÿæ›´æ–°
            if (currentLatencyInterval) {
                clearInterval(currentLatencyInterval);
                currentLatencyInterval = null;
            }
            
            // é‡ç½®æ˜¾ç¤º
            updateLatencyStats(null);
            
            // é‡ç½®å®æ—¶å»¶è¿Ÿæ˜¾ç¤º
            document.getElementById('currentLatency').textContent = '-';
            document.getElementById('webrtcRtt').textContent = '-';
            document.getElementById('videoPlaybackLatency').textContent = '-';
            
            // æ¸…ç†å¸§æ—¶é—´è®°å½•
            frameReceiveTimes = [];
            lastFrameTime = null;
            serverCurrentLatency = null; // âœ… æ¸…ç†æœåŠ¡å™¨å»¶è¿Ÿå€¼
        }
        
        // æ›´æ–°å»¶æ—¶ç»Ÿè®¡æ˜¾ç¤º
        function updateLatencyStats(stats) {
            if (!stats) {
                document.getElementById('latencyTotalAvg').textContent = '-';
                document.getElementById('latencyTotalRange').textContent = '-';
                document.getElementById('latencyNetworkAvg').textContent = '-';
                document.getElementById('latencyServerAvg').textContent = '-';
                document.getElementById('latencySampleCount').textContent = '0';
                return;
            }
            
            document.getElementById('latencyTotalAvg').textContent = 
                stats.totalLatencyAvg > 0 ? `${stats.totalLatencyAvg.toFixed(1)} ms` : '-';
            document.getElementById('latencyTotalRange').textContent = 
                stats.totalLatencyMin > 0 && stats.totalLatencyMax > 0 
                    ? `${stats.totalLatencyMin.toFixed(1)} / ${stats.totalLatencyMax.toFixed(1)} ms`
                    : '-';
            document.getElementById('latencyNetworkAvg').textContent = 
                stats.networkTransmitAvg > 0 ? `${stats.networkTransmitAvg.toFixed(1)} ms` : '-';
            document.getElementById('latencyServerAvg').textContent = 
                stats.serverProcessingAvg > 0 ? `${stats.serverProcessingAvg.toFixed(1)} ms` : '-';
            document.getElementById('latencySampleCount').textContent = stats.sampleCount || 0;
        }
        
        // è¿æ¥ SignalR æ§åˆ¶å™¨
        async function connectControllerSignalR(sessionId) {
            // âœ… é˜²æ­¢å¹¶å‘è¿æ¥
            if (isConnecting) {
                log('âš ï¸ SignalR è¿æ¥æ­£åœ¨è¿›è¡Œä¸­ï¼Œè·³è¿‡é‡å¤è¿æ¥', 'warning');
                return;
            }
            
            // âœ… å¦‚æœå·²ç»è¿æ¥ä¸”çŠ¶æ€æ­£å¸¸ï¼Œç›´æ¥è¿”å›ï¼ˆä¸»è¦æ£€æŸ¥è¿æ¥çŠ¶æ€ï¼‰
            if (controllerConnection && 
                controllerConnection.state === signalR.HubConnectionState.Connected) {
                log('âœ… SignalR å·²è¿æ¥ï¼Œè·³è¿‡é‡å¤è¿æ¥', 'info');
                // ç¡®ä¿ controllerConnected æ ‡å¿—ä¹Ÿæ­£ç¡®
                controllerConnected = true;
                return;
            }
            
            isConnecting = true;
            
            const token = getAuthToken();
            if (!token) {
                log('âŒ æœªæ£€æµ‹åˆ° JWT Tokenï¼Œæ— æ³•å»ºç«‹ SignalR è¿æ¥', 'error');
                isConnecting = false;
                return;
            }

            try {
                // âœ… å¦‚æœå·²æœ‰è¿æ¥ä½†åœ¨éæ­£å¸¸çŠ¶æ€ï¼Œå…ˆæ¸…ç†
                if (controllerConnection) {
                    const currentState = controllerConnection.state;
                    if (currentState === signalR.HubConnectionState.Connecting) {
                        log('âš ï¸ æ£€æµ‹åˆ°è¿æ¥æ­£åœ¨è¿›è¡Œä¸­ï¼Œç­‰å¾…å®Œæˆ...', 'warning');
                        // ç­‰å¾…æœ€å¤š3ç§’è®©è¿æ¥å®Œæˆ
                        for (let i = 0; i < 30; i++) {
                            await new Promise(resolve => setTimeout(resolve, 100));
                            if (controllerConnection.state === signalR.HubConnectionState.Connected) {
                                isConnecting = false;
                                return; // è¿æ¥å·²æˆåŠŸ
                            }
                            if (controllerConnection.state === signalR.HubConnectionState.Disconnected) {
                                break; // è¿æ¥å·²æ–­å¼€ï¼Œå¯ä»¥é‡æ–°è¿æ¥
                            }
                        }
                    }
                    
                    // åªæœ‰åœ¨é Connecting çŠ¶æ€æ—¶æ‰æ–­å¼€
                    if (controllerConnection.state !== signalR.HubConnectionState.Connecting) {
                        await disconnectControllerSignalR();
                    } else {
                        // å¦‚æœè¿˜åœ¨ Connectingï¼Œç­‰å¾…æˆ–å–æ¶ˆ
                        try {
                            await controllerConnection.stop();
                        } catch (e) {
                            // å¿½ç•¥é”™è¯¯
                        }
                        controllerConnection = null;
                    }
                }
                
                log('ğŸ”Œ æ­£åœ¨è¿æ¥ SignalR æ§åˆ¶å™¨...', 'info');
                
                // âœ… æ£€æŸ¥ SignalR åº“æ˜¯å¦å·²åŠ è½½
                if (typeof signalR === 'undefined' || !signalR.HubConnectionBuilder) {
                    throw new Error('SignalR åº“æœªåŠ è½½ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥æˆ– CDN çŠ¶æ€');
                }
                
                controllerConnection = new signalR.HubConnectionBuilder()
                    .withUrl('/hubs/controller', {
                        accessTokenFactory: () => getAuthToken() || ''
                    })
                    .withAutomaticReconnect({
                        nextRetryDelayInMilliseconds: retryContext => {
                            // é‡è¯•ç­–ç•¥ï¼šå‰3æ¬¡å¿«é€Ÿé‡è¯•ï¼Œä¹‹åé€æ¸å¢åŠ é—´éš”
                            if (retryContext.previousRetryCount < 3) {
                                return 1000; // 1ç§’
                            } else {
                                return Math.min(30000, 1000 * Math.pow(2, retryContext.previousRetryCount - 2)); // æœ€å¤š30ç§’
                            }
                        }
                    })
                    .build();
                
                // æ³¨å†Œäº‹ä»¶ï¼ˆåœ¨ start ä¹‹å‰ï¼‰
                controllerConnection.on('ControllerConnected', (success) => {
                    if (success) {
                        log(`âœ… æ§åˆ¶å™¨å·²é€šè¿‡ SignalR è¿æ¥`, 'success');
                        controllerConnected = true;
                    } else {
                        log(`âš ï¸ æ§åˆ¶å™¨è¿æ¥è¿”å›å¤±è´¥ï¼Œå°†åœ¨å¯åŠ¨æ—¶éªŒè¯å®é™…çŠ¶æ€`, 'warning');
                        // ä¸ç«‹å³è®¾ç½® controllerConnected = falseï¼Œç­‰å¾… StartController çš„ç»“æœ
                    }
                });
                
                controllerConnection.on('ControllerStarted', (success) => {
                    if (success) {
                        log(`âœ… æ§åˆ¶å™¨å·²å¯åŠ¨: ${success}`, 'success');
                        // å¦‚æœæ§åˆ¶å™¨å¯åŠ¨æˆåŠŸï¼Œè¯´æ˜è¿æ¥æ˜¯æ­£å¸¸çš„
                        controllerConnected = true;
                    } else {
                        log(`âš ï¸ æ§åˆ¶å™¨å¯åŠ¨å¤±è´¥: ${success}`, 'warning');
                    }
                });
                
                controllerConnection.on('Error', (message) => {
                    // åŒºåˆ†é”™è¯¯ç±»å‹ï¼šå¦‚æœæ˜¯"å·²è¿æ¥"é”™è¯¯ï¼Œä¸ç®—çœŸæ­£çš„é”™è¯¯
                    if (message && message.includes('å·²è¿æ¥')) {
                        log(`â„¹ï¸ SignalR æç¤º: ${message}`, 'info');
                        // å¦‚æœæç¤ºå·²è¿æ¥ï¼Œè®¾ç½®è¿æ¥çŠ¶æ€ä¸º true
                        controllerConnected = true;
                    } else {
                        log(`âŒ SignalR é”™è¯¯: ${message}`, 'error');
                    }
                });
                
                controllerConnection.onclose((error) => {
                    if (error) {
                        log(`âš ï¸ SignalR è¿æ¥å·²å…³é—­ï¼ˆé”™è¯¯: ${error.message}ï¼‰`, 'warning');
                    } else {
                        log('âš ï¸ SignalR è¿æ¥å·²å…³é—­', 'warning');
                    }
                    controllerConnected = false;
                    isConnecting = false;
                    
                    // åªæœ‰åœ¨éæ‰‹åŠ¨æ–­å¼€ä¸”ä¸æ˜¯è¿æ¥å¤±è´¥æ—¶æ‰å°è¯•è‡ªåŠ¨é‡è¿
                    if (!isManualDisconnect && remotePlaySessionId) {
                        // å»¶è¿Ÿé‡è¿ï¼Œé¿å…é¢‘ç¹é‡è¿
                        setTimeout(async () => {
                            // å†æ¬¡æ£€æŸ¥æ˜¯å¦åº”è¯¥é‡è¿ï¼ˆç¡®ä¿ä¸æ˜¯æ‰‹åŠ¨æ–­å¼€ï¼Œä¸”ç¡®å®æ–­å¼€äº†ï¼‰
                            if (!isManualDisconnect && 
                                remotePlaySessionId &&
                                (!controllerConnection || controllerConnection.state === signalR.HubConnectionState.Disconnected)) {
                                log('ğŸ”„ SignalR è¿æ¥æ„å¤–æ–­å¼€ï¼Œå°è¯•è‡ªåŠ¨é‡è¿...', 'info');
                                try {
                                    await connectControllerSignalR(remotePlaySessionId);
                                } catch (reconnectError) {
                                    log(`âŒ è‡ªåŠ¨é‡è¿å¤±è´¥: ${reconnectError.message}`, 'error');
                                }
                            }
                        }, 2000); // å»¶è¿Ÿ2ç§’é‡è¿
                    }
                });
                
                // âœ… å¯åŠ¨è¿æ¥ - start() ä¼šç­‰å¾…è¿æ¥å»ºç«‹
                await controllerConnection.start();
                
                // âœ… ç­‰å¾…è¿æ¥çŠ¶æ€å˜ä¸º Connectedï¼ˆæœ€å¤šç­‰å¾…2ç§’ï¼‰
                let waitCount = 0;
                while (controllerConnection.state !== signalR.HubConnectionState.Connected && waitCount < 20) {
                    await new Promise(resolve => setTimeout(resolve, 100));
                    waitCount++;
                }
                
                // âœ… éªŒè¯è¿æ¥çŠ¶æ€
                const state = controllerConnection.state;
                if (state !== signalR.HubConnectionState.Connected) {
                    throw new Error(`SignalR è¿æ¥æœªæˆåŠŸå»ºç«‹ï¼Œå½“å‰çŠ¶æ€: ${state}`);
                }
                
                log('âœ… SignalR è¿æ¥å·²å»ºç«‹', 'success');
                
                // è¿æ¥æ§åˆ¶å™¨åˆ°ä¼šè¯ï¼ˆå¦‚æœå¤±è´¥ï¼Œå¯èƒ½æ˜¯å·²ç»è¿æ¥è¿‡äº†ï¼‰
                let connectResult = false;
                try {
                    // ConnectController ç°åœ¨ä¼šè¿”å›æˆåŠŸï¼ˆé€šè¿‡äº‹ä»¶ï¼‰ï¼Œä½†æˆ‘ä»¬éœ€è¦ç­‰å¾…äº‹ä»¶
                    await controllerConnection.invoke('ConnectController', sessionId);
                    // ç­‰å¾…ä¸€ä¸‹è®© ControllerConnected äº‹ä»¶å¤„ç†ï¼ˆæœ€å¤šç­‰å¾…500msï¼‰
                    for (let i = 0; i < 5; i++) {
                        await new Promise(resolve => setTimeout(resolve, 100));
                        if (controllerConnected) {
                            connectResult = true;
                            break;
                        }
                    }
                } catch (connectError) {
                    log(`âš ï¸ ConnectController è°ƒç”¨å¼‚å¸¸: ${connectError.message}ï¼Œç»§ç»­å°è¯•å¯åŠ¨`, 'warning');
                }
                
                // å¯åŠ¨æ§åˆ¶å™¨ï¼ˆå¦‚æœå¯åŠ¨æˆåŠŸï¼Œè¯´æ˜è¿æ¥æ˜¯æ­£å¸¸çš„ï¼‰
                let startResult = false;
                try {
                    await controllerConnection.invoke('StartController', sessionId);
                    // ç­‰å¾…ä¸€ä¸‹è®© ControllerStarted äº‹ä»¶å¤„ç†ï¼ˆæœ€å¤šç­‰å¾…500msï¼‰
                    for (let i = 0; i < 5; i++) {
                        await new Promise(resolve => setTimeout(resolve, 100));
                        // å¦‚æœæ”¶åˆ° ControllerStarted äº‹ä»¶ï¼ŒconnectResult ä¼šåœ¨äº‹ä»¶å¤„ç†ä¸­è®¾ç½®
                        if (controllerConnected) {
                            startResult = true;
                            break;
                        }
                    }
                    
                    // å¦‚æœå¯åŠ¨æˆåŠŸï¼Œç¡®ä¿è¿æ¥çŠ¶æ€ä¸º true
                    if (controllerConnection.state === signalR.HubConnectionState.Connected) {
                        controllerConnected = true;
                        startResult = true;
                    }
                } catch (startError) {
                    log(`âš ï¸ StartController è°ƒç”¨å¤±è´¥: ${startError.message}`, 'warning');
                }
                
                // æœ€ç»ˆéªŒè¯ï¼šå¦‚æœè¿æ¥çŠ¶æ€æ­£å¸¸ï¼Œå³ä½¿äº‹ä»¶æœªåŠæ—¶è§¦å‘ï¼Œä¹Ÿè®¤ä¸ºè¿æ¥æˆåŠŸ
                if (controllerConnection.state === signalR.HubConnectionState.Connected) {
                    // å¦‚æœ StartController æˆåŠŸï¼ˆå³ä½¿ ConnectController å¤±è´¥ï¼‰ï¼Œä¹Ÿè®¤ä¸ºè¿æ¥æˆåŠŸ
                    if (startResult || connectResult) {
                        controllerConnected = true;
                        log(`âœ… æ§åˆ¶å™¨è¿æ¥éªŒè¯æˆåŠŸï¼ˆConnect: ${connectResult}, Start: ${startResult}ï¼‰`, 'success');
                    } else if (!controllerConnected) {
                        // å¦‚æœéƒ½æ²¡æœ‰æˆåŠŸï¼Œä½†è¿æ¥çŠ¶æ€æ­£å¸¸ï¼Œå¯èƒ½æ˜¯äº‹ä»¶å»¶è¿Ÿï¼Œå†ç­‰å¾…ä¸€ä¸‹
                        log(`âš ï¸ ç­‰å¾…æ§åˆ¶å™¨è¿æ¥äº‹ä»¶...`, 'warning');
                        await new Promise(resolve => setTimeout(resolve, 500));
                        // å†æ¬¡æ£€æŸ¥
                        if (!controllerConnected && controllerConnection.state === signalR.HubConnectionState.Connected) {
                            // å¦‚æœè¿æ¥çŠ¶æ€æ­£å¸¸ï¼Œå³ä½¿æ²¡æœ‰æ”¶åˆ°äº‹ä»¶ï¼Œä¹Ÿè®¤ä¸ºè¿æ¥å¯ç”¨ï¼ˆå¯èƒ½æ˜¯äº‹ä»¶ä¸¢å¤±ï¼‰
                            controllerConnected = true;
                            log(`âœ… è¿æ¥çŠ¶æ€æ­£å¸¸ï¼Œå‡è®¾è¿æ¥æˆåŠŸï¼ˆå¯èƒ½äº‹ä»¶ä¸¢å¤±ï¼‰`, 'info');
                        }
                    }
                }
                
            } catch (error) {
                log(`âŒ SignalR è¿æ¥å¤±è´¥: ${error.message}`, 'error');
                if (controllerConnection) {
                    try {
                        // âœ… åªåœ¨è¿æ¥çŠ¶æ€ä¸æ˜¯ Disconnected æ—¶æ‰è°ƒç”¨ stop
                        const currentState = controllerConnection.state;
                        if (currentState !== signalR.HubConnectionState.Disconnected &&
                            currentState !== signalR.HubConnectionState.Disconnecting) {
                            // å¦‚æœæ­£åœ¨è¿æ¥ï¼Œç­‰å¾…ä¸€å°æ®µæ—¶é—´å†åœæ­¢
                            if (currentState === signalR.HubConnectionState.Connecting) {
                                await new Promise(resolve => setTimeout(resolve, 500));
                            }
                            if (controllerConnection.state !== signalR.HubConnectionState.Disconnected) {
                                await controllerConnection.stop();
                            }
                        }
                    } catch (stopError) {
                        // å¿½ç•¥åœæ­¢æ—¶çš„é”™è¯¯ï¼ˆå¯èƒ½å·²ç»æ–­å¼€ï¼‰
                        log(`âš ï¸ åœæ­¢ SignalR è¿æ¥æ—¶å‡ºé”™ï¼ˆå¯å¿½ç•¥ï¼‰: ${stopError.message}`, 'warning');
                    }
                }
                controllerConnection = null;
                controllerConnected = false;
            } finally {
                isConnecting = false;
            }
        }
        
        // æ–­å¼€ SignalR æ§åˆ¶å™¨
        let isManualDisconnect = false; // æ ‡è®°æ˜¯å¦ä¸ºæ‰‹åŠ¨æ–­å¼€
        async function disconnectControllerSignalR() {
            if (controllerConnection) {
                try {
                    // âœ… æ ‡è®°ä¸ºæ‰‹åŠ¨æ–­å¼€ï¼Œé¿å…è‡ªåŠ¨é‡è¿
                    isManualDisconnect = true;
                    
                    // âœ… æ£€æŸ¥è¿æ¥çŠ¶æ€ï¼Œåªæœ‰åœ¨è¿æ¥æ—¶æ‰è°ƒç”¨æ–¹æ³•
                    if (controllerConnection.state === signalR.HubConnectionState.Connected) {
                        if (remotePlaySessionId) {
                            try {
                                await controllerConnection.invoke('DisconnectController', remotePlaySessionId);
                            } catch (invokeError) {
                                // å¿½ç•¥è°ƒç”¨é”™è¯¯ï¼ˆå¯èƒ½å·²ç»æ–­å¼€ï¼‰
                                log(`âš ï¸ DisconnectController è°ƒç”¨å¤±è´¥ï¼ˆå¯å¿½ç•¥ï¼‰: ${invokeError.message}`, 'warning');
                            }
                        }
                        if (controllerConnection.state !== signalR.HubConnectionState.Disconnected) {
                            await controllerConnection.stop();
                        }
                    }
                    log('âœ… SignalR è¿æ¥å·²æ–­å¼€', 'info');
                } catch (error) {
                    log(`âš ï¸ æ–­å¼€ SignalR è¿æ¥æ—¶å‡ºé”™: ${error.message}`, 'warning');
                } finally {
                    controllerConnection = null;
                    controllerConnected = false;
                    // é‡ç½®æ‰‹åŠ¨æ–­å¼€æ ‡è®°ï¼ˆå»¶è¿Ÿä¸€ç‚¹ï¼Œç¡®ä¿ onclose äº‹ä»¶å·²ç»å¤„ç†ï¼‰
                    setTimeout(() => {
                        isManualDisconnect = false;
                    }, 1000);
                }
            }
        }

        // ä¼˜åŒ– SDP ä»¥é™ä½å»¶è¿Ÿï¼ˆç®€åŒ–ç‰ˆæœ¬ï¼Œæ›´å®‰å…¨ï¼‰
        function optimizeSdpForLowLatency(sdp) {
            try {
                if (!sdp || typeof sdp !== 'string' || sdp.length < 10) {
                    return sdp;
                }
                
                // æ£€æŸ¥æ˜¯å¦å·²ç»åŒ…å«ä¼˜åŒ–æ ‡è®°ï¼ˆé¿å…é‡å¤æ·»åŠ ï¼‰
                if (sdp.includes('a=x-google-flag:low-latency') && 
                    sdp.includes('a=minBufferedPlaybackTime')) {
                    return sdp; // å·²ç»ä¼˜åŒ–è¿‡äº†
                }
                
                const lines = sdp.split(/\r?\n/);
                const optimizedLines = [];
                let foundVideoMedia = false;
                let foundAudioMedia = false;
                let videoOptimized = false;
                let audioOptimized = false;
                
                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i];
                    optimizedLines.push(line);
                    
                    // æ£€æµ‹åª’ä½“è¡Œ
                    if (line.trim().startsWith('m=video ')) {
                        foundVideoMedia = true;
                        foundAudioMedia = false;
                        videoOptimized = false;
                    } else if (line.trim().startsWith('m=audio ')) {
                        foundAudioMedia = true;
                        foundVideoMedia = false;
                        audioOptimized = false;
                    } else if (line.trim().startsWith('m=')) {
                        // å…¶ä»–åª’ä½“ç±»å‹ï¼Œé‡ç½®çŠ¶æ€
                        foundVideoMedia = false;
                        foundAudioMedia = false;
                    }
                    
                    // åœ¨è§†é¢‘åª’ä½“éƒ¨åˆ†çš„ç¬¬ä¸€ä¸ªå±æ€§è¡Œåæ·»åŠ ä¼˜åŒ–ï¼ˆç¡®ä¿æ ¼å¼æ­£ç¡®ï¼‰
                    if (foundVideoMedia && !videoOptimized && line.trim().startsWith('a=') && 
                        !line.trim().startsWith('a=rtcp:') && 
                        line.trim().length > 2) {
                        // åªåœ¨ç¬¬ä¸€ä¸ªæœ‰æ•ˆçš„å±æ€§è¡Œåæ·»åŠ 
                        if (!sdp.includes('a=x-google-flag:low-latency')) {
                            optimizedLines.push('a=x-google-flag:low-latency');
                        }
                        if (!sdp.includes('a=minBufferedPlaybackTime')) {
                            optimizedLines.push('a=minBufferedPlaybackTime:0');
                        }
                        videoOptimized = true;
                    }
                    
                    // åœ¨éŸ³é¢‘åª’ä½“éƒ¨åˆ†çš„ç¬¬ä¸€ä¸ªå±æ€§è¡Œåæ·»åŠ ä¼˜åŒ–
                    if (foundAudioMedia && !audioOptimized && line.trim().startsWith('a=') && 
                        !line.trim().startsWith('a=rtcp:') && 
                        line.trim().length > 2) {
                        if (!sdp.includes('a=minBufferedPlaybackTime')) {
                            optimizedLines.push('a=minBufferedPlaybackTime:0');
                        }
                        audioOptimized = true;
                    }
                }
                
                const result = optimizedLines.join('\r\n');
                
                // éªŒè¯ç»“æœ
                if (!result || result.length < sdp.length * 0.5) {
                    // å¦‚æœç»“æœæ˜æ˜¾çŸ­äºåŸå§‹ SDPï¼Œå¯èƒ½å‡ºé”™äº†
                    return sdp;
                }
                
                // ç¡®ä¿ SDP åŸºæœ¬ç»“æ„å®Œæ•´
                if (!result.includes('v=0') || !result.includes('m=')) {
                    return sdp;
                }
                
                return result;
            } catch (error) {
                console.error('SDP ä¼˜åŒ–é”™è¯¯:', error);
                return sdp; // å‡ºé”™æ—¶è¿”å›åŸå§‹ SDP
            }
        }
        
        // é¡µé¢åŠ è½½æ—¶çš„åˆå§‹åŒ–
        window.addEventListener('load', () => {
            updateAuthTokenStatus();
            log('WebRTC Player å·²å°±ç»ª', 'success');
            log('è¯·è¾“å…¥ Host ID æˆ– Session ID å¹¶ç‚¹å‡»è¿æ¥', 'info');
            
            // ä¼˜åŒ–è§†é¢‘å…ƒç´ ä»¥é™ä½å»¶è¿Ÿï¼ˆé›¶ç¼“å†²æ¨¡å¼ï¼‰
            const video = document.getElementById('remoteVideo');
            if (video) {
                // âœ… é›¶ç¼“å†²åˆå§‹åŒ–è®¾ç½®
                video.preload = 'none'; // ç¦ç”¨é¢„åŠ è½½
                video.autoplay = true; // è‡ªåŠ¨æ’­æ”¾
                video.playsInline = true; // å†…è”æ’­æ”¾
                
                // è®¾ç½®è§†é¢‘å±æ€§ä»¥é™ä½å»¶è¿Ÿ
                video.addEventListener('loadedmetadata', () => {
                    log('âœ… è§†é¢‘å…ƒæ•°æ®å·²åŠ è½½ï¼ˆé›¶ç¼“å†²æ¨¡å¼ï¼‰', 'info');
                    // ç¡®ä¿æ’­æ”¾é€Ÿåº¦æ­£å¸¸
                    video.playbackRate = 1.0;
                    video.defaultPlaybackRate = 1.0;
                });
                
                // ç›‘å¬æ’­æ”¾äº‹ä»¶
                video.addEventListener('playing', () => {
                    log('âœ… è§†é¢‘å¼€å§‹æ’­æ”¾ï¼ˆé›¶ç¼“å†²æ¨¡å¼ï¼‰', 'success');
                });
                
                // ç›‘å¬ç­‰å¾…äº‹ä»¶ï¼ˆç¼“å†²ä¸è¶³æ—¶ï¼‰
                video.addEventListener('waiting', () => {
                    log('âš ï¸ è§†é¢‘ç­‰å¾…ç¼“å†²ï¼ˆç¼“å†²ä¸è¶³ï¼‰', 'warning');
                });
                
                // ç›‘å¬åœæ»äº‹ä»¶
                video.addEventListener('stalled', () => {
                    log('âš ï¸ è§†é¢‘åœæ»ï¼ˆå¯èƒ½ç¼“å†²ä¸è¶³ï¼‰', 'warning');
                });
            }
        });

        // æ§åˆ¶å™¨æŒ‰é’®å¤„ç†å‡½æ•°ï¼ˆä½¿ç”¨ SignalR ä½å»¶è¿Ÿï¼‰
        // action: 'press', 'release', 'tap'
        async function sendControllerButton(buttonName, action = 'tap') {
            if (!remotePlaySessionId) {
                log('âŒ æ²¡æœ‰æ´»åŠ¨çš„ Remote Play Sessionï¼Œæ— æ³•å‘é€æ§åˆ¶å™¨å‘½ä»¤', 'error');
                alert('è¯·å…ˆè¿æ¥ Remote Play Session');
                return;
            }

            // âœ… å¦‚æœæ­£åœ¨è¿æ¥ï¼Œç­‰å¾…è¿æ¥å®Œæˆï¼ˆæœ€å¤šç­‰å¾…2ç§’ï¼‰
            if (isConnecting) {
                log('âš ï¸ SignalR æ­£åœ¨è¿æ¥ä¸­ï¼Œç­‰å¾…å®Œæˆ...', 'warning');
                for (let i = 0; i < 20; i++) {
                    await new Promise(resolve => setTimeout(resolve, 100));
                    if (!isConnecting) {
                        break; // è¿æ¥å®Œæˆæˆ–å¤±è´¥
                    }
                }
            }

            // æ£€æŸ¥ SignalR è¿æ¥çŠ¶æ€ï¼ˆä¸»è¦æ£€æŸ¥è¿æ¥çŠ¶æ€ï¼‰
            const isConnected = controllerConnection && 
                               controllerConnection.state === signalR.HubConnectionState.Connected;
            
            // å¦‚æœè¿æ¥çŠ¶æ€æ­£å¸¸ï¼Œå³ä½¿ controllerConnected ä¸º falseï¼Œä¹Ÿå°è¯•ä½¿ç”¨ï¼ˆå¯èƒ½æ˜¯çŠ¶æ€æ›´æ–°å»¶è¿Ÿï¼‰
            // åªæœ‰åœ¨è¿æ¥çŠ¶æ€çœŸæ­£æ–­å¼€æ—¶æ‰å°è¯•é‡è¿
            if (!isConnected) {
                // å¦‚æœæ­£åœ¨è¿æ¥ï¼Œå†ç­‰å¾…ä¸€ä¸‹
                if (isConnecting) {
                    log('âš ï¸ SignalR è¿æ¥ä»åœ¨è¿›è¡Œä¸­ï¼Œç­‰å¾…å®Œæˆ...', 'warning');
                    await new Promise(resolve => setTimeout(resolve, 500));
                }
                
                // å†æ¬¡æ£€æŸ¥è¿æ¥çŠ¶æ€
                const stillNotConnected = !controllerConnection || 
                                        controllerConnection.state !== signalR.HubConnectionState.Connected;
                
                if (stillNotConnected && !isConnecting) {
                    // åªæœ‰åœ¨ä¸åœ¨è¿æ¥ä¸­æ—¶æ‰å°è¯•è¿æ¥
                    log('âš ï¸ SignalR è¿æ¥æ–­å¼€ï¼Œå°è¯•é‡æ–°è¿æ¥...', 'warning');
                    await connectControllerSignalR(remotePlaySessionId);
                    
                    // å†æ¬¡æ£€æŸ¥è¿æ¥çŠ¶æ€
                    const reconnectSuccess = controllerConnection && 
                                           controllerConnection.state === signalR.HubConnectionState.Connected;
                    
                    if (!reconnectSuccess) {
                        log('âŒ SignalR é‡è¿å¤±è´¥ï¼Œä½¿ç”¨ HTTP API ä½œä¸ºå¤‡ç”¨', 'error');
                        // å¤‡ç”¨æ–¹æ¡ˆï¼šä½¿ç”¨ HTTP API
                        await sendControllerButtonHTTP(buttonName, action);
                        return;
                    }
                } else if (stillNotConnected) {
                    // å¦‚æœè¿˜åœ¨è¿æ¥ä¸­ï¼Œä½¿ç”¨ HTTP API ä½œä¸ºå¤‡ç”¨
                    log('âš ï¸ SignalR ä»åœ¨è¿æ¥ä¸­ï¼Œä½¿ç”¨ HTTP API ä½œä¸ºä¸´æ—¶å¤‡ç”¨', 'warning');
                    await sendControllerButtonHTTP(buttonName, action);
                    return;
                }
            }

            try {
                // âœ… å†æ¬¡æ£€æŸ¥è¿æ¥çŠ¶æ€ï¼Œç¡®ä¿åœ¨è°ƒç”¨å‰è¿æ¥å¯ç”¨
                if (!controllerConnection || 
                    controllerConnection.state !== signalR.HubConnectionState.Connected) {
                    throw new Error('SignalR è¿æ¥ä¸å¯ç”¨');
                }
                
                const startTime = performance.now();
                const delayMs = action === 'tap' ? 100 : 0;
                await controllerConnection.invoke('Button', remotePlaySessionId, buttonName, action, delayMs);
                const endTime = performance.now();
                const latency = (endTime - startTime).toFixed(2);
                log(`âœ… æ§åˆ¶å™¨å‘½ä»¤å·²å‘é€ (SignalR): ${buttonName} [${action}] - å»¶è¿Ÿ: ${latency}ms`, 'success');
            } catch (error) {
                log(`âŒ SignalR å‘é€å¤±è´¥: ${error.message}ï¼Œå°è¯•ä½¿ç”¨ HTTP API`, 'error');
                // å¤‡ç”¨æ–¹æ¡ˆï¼šä½¿ç”¨ HTTP API
                await sendControllerButtonHTTP(buttonName, action);
            }
        }
        
        // HTTP API å¤‡ç”¨æ–¹æ¡ˆ
        async function sendControllerButtonHTTP(buttonName, action = 'tap') {
            try {
                const response = await authorizedFetch('/api/PlayStation/controller/button', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        sessionId: remotePlaySessionId,
                        button: buttonName,
                        action: action,
                        delayMs: action === 'tap' ? 200 : 0
                    })
                });

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }

                const result = await response.json();
                if (result.success) {
                    log(`âœ… æ§åˆ¶å™¨å‘½ä»¤å·²å‘é€ (HTTP): ${buttonName} [${action}]`, 'success');
                } else {
                    log(`âš ï¸ æ§åˆ¶å™¨å‘½ä»¤å¤±è´¥: ${result.errorMessage || 'æœªçŸ¥é”™è¯¯'}`, 'warning');
                }
            } catch (error) {
                log(`âŒ HTTP API å‘é€å¤±è´¥: ${error.message}`, 'error');
            }
        }
        
        // è·Ÿè¸ªå½“å‰æŒ‰ä¸‹çš„æŒ‰é’®ï¼ˆç”¨äºé•¿æŒ‰ï¼‰
        const pressedButtons = new Map(); // buttonName -> { pressTimer, releaseTimer }

        // åˆå§‹åŒ–æ§åˆ¶å™¨æŒ‰é’®äº‹ä»¶
        function initControllerButtons() {
            const controllerButtons = document.querySelectorAll('.controller-btn[data-button]');
            log(`åˆå§‹åŒ–æ§åˆ¶å™¨æŒ‰é’®: æ‰¾åˆ° ${controllerButtons.length} ä¸ªæŒ‰é’®`, 'info');
            
            if (controllerButtons.length === 0) {
                log(`âš ï¸ æœªæ‰¾åˆ°ä»»ä½•æ§åˆ¶å™¨æŒ‰é’®ï¼Œè¯·æ£€æŸ¥ HTML ç»“æ„`, 'warning');
                return;
            }
            
            controllerButtons.forEach((btn, index) => {
                const buttonName = btn.getAttribute('data-button');
                if (!buttonName) {
                    log(`âš ï¸ æŒ‰é’® ${index} æ²¡æœ‰ data-button å±æ€§`, 'warning');
                    return;
                }
                
                // æ·»åŠ ç‚¹å‡»äº‹ä»¶ï¼ˆè½»æŒ‰ï¼Œå¿«é€ŸæŒ‰ä¸‹å¹¶é‡Šæ”¾ï¼‰
                btn.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    log(`ğŸ® ç‚¹å‡»æŒ‰é’®: ${buttonName}`, 'info');
                    sendControllerButton(buttonName, 'tap');
                    
                    // æ·»åŠ è§†è§‰åé¦ˆ
                    const originalTransform = btn.style.transform;
                    btn.style.transform = 'scale(0.95)';
                    setTimeout(() => {
                        btn.style.transform = originalTransform || '';
                    }, 100);
                }, false);
                
                // æ·»åŠ é¼ æ ‡æŒ‰ä¸‹äº‹ä»¶ï¼ˆé•¿æŒ‰å¼€å§‹ï¼‰
                btn.addEventListener('mousedown', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    this.style.opacity = '0.7';
                    this.style.transform = 'scale(0.95)';
                    
                    // å¦‚æœå·²ç»åœ¨æŒ‰ä¸‹çŠ¶æ€ï¼Œå…ˆé‡Šæ”¾
                    if (pressedButtons.has(buttonName)) {
                        const existing = pressedButtons.get(buttonName);
                        if (existing.pressTimer) {
                            clearTimeout(existing.pressTimer);
                        }
                        if (existing.releaseTimer) {
                            clearTimeout(existing.releaseTimer);
                        }
                        // å…ˆå‘é€é‡Šæ”¾
                        sendControllerButton(buttonName, 'release');
                    }
                    
                    // å‘é€æŒ‰ä¸‹äº‹ä»¶
                    sendControllerButton(buttonName, 'press');
                    
                    // è®°å½•æŒ‰ä¸‹çŠ¶æ€
                    pressedButtons.set(buttonName, {
                        pressTimer: null,
                        releaseTimer: null,
                        button: this
                    });
                    
                    log(`ğŸ® æŒ‰é’®æŒ‰ä¸‹: ${buttonName} (é•¿æŒ‰æ¨¡å¼)`, 'info');
                }, false);
                
                // æ·»åŠ é¼ æ ‡é‡Šæ”¾äº‹ä»¶ï¼ˆé•¿æŒ‰ç»“æŸï¼‰
                btn.addEventListener('mouseup', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    this.style.opacity = '1';
                    this.style.transform = '';
                    
                    // å¦‚æœæŒ‰é’®åœ¨æŒ‰ä¸‹çŠ¶æ€ï¼Œå‘é€é‡Šæ”¾
                    if (pressedButtons.has(buttonName)) {
                        sendControllerButton(buttonName, 'release');
                        pressedButtons.delete(buttonName);
                        log(`ğŸ® æŒ‰é’®é‡Šæ”¾: ${buttonName}`, 'info');
                    }
                }, false);
                
                // é¼ æ ‡ç¦»å¼€æ—¶ä¹Ÿé‡Šæ”¾
                btn.addEventListener('mouseleave', function(e) {
                    this.style.opacity = '1';
                    this.style.transform = '';
                    
                    // å¦‚æœæŒ‰é’®åœ¨æŒ‰ä¸‹çŠ¶æ€ï¼Œå‘é€é‡Šæ”¾
                    if (pressedButtons.has(buttonName)) {
                        sendControllerButton(buttonName, 'release');
                        pressedButtons.delete(buttonName);
                        log(`ğŸ® æŒ‰é’®ç¦»å¼€é‡Šæ”¾: ${buttonName}`, 'info');
                    }
                }, false);
                
                // è§¦æ‘¸äº‹ä»¶æ”¯æŒï¼ˆç§»åŠ¨è®¾å¤‡ï¼‰
                btn.addEventListener('touchstart', function(e) {
                    e.preventDefault();
                    this.dispatchEvent(new MouseEvent('mousedown', { bubbles: true }));
                }, false);
                
                btn.addEventListener('touchend', function(e) {
                    e.preventDefault();
                    this.dispatchEvent(new MouseEvent('mouseup', { bubbles: true }));
                }, false);
                
                log(`âœ… å·²ç»‘å®šæŒ‰é’®: ${buttonName} (æ”¯æŒé•¿æŒ‰)`, 'info');
            });
            
            log(`âœ… æ§åˆ¶å™¨æŒ‰é’®åˆå§‹åŒ–å®Œæˆï¼Œå…±ç»‘å®š ${controllerButtons.length} ä¸ªæŒ‰é’®`, 'success');
        }

        // é”®ç›˜æ˜ å°„é…ç½®
        const keyboardMapping = {
            // æ–¹å‘é”®
            'KeyW': 'UP',
            'ArrowUp': 'UP',
            'KeyS': 'DOWN',
            'ArrowDown': 'DOWN',
            'KeyA': 'LEFT',
            'ArrowLeft': 'LEFT',
            'KeyD': 'RIGHT',
            'ArrowRight': 'RIGHT',
            // ä¸»è¦æŒ‰é’®
            'Space': 'CROSS',
            'Enter': 'CIRCLE',
            'ShiftLeft': 'SQUARE',
            'ShiftRight': 'SQUARE',
            'ControlLeft': 'TRIANGLE',
            'ControlRight': 'TRIANGLE',
            // è‚©é”®
            'KeyQ': 'L1',
            'KeyE': 'R1',
            'KeyZ': 'L2',
            'KeyC': 'R2',
            // åŠŸèƒ½é”®
            'Tab': 'OPTIONS',
            'Backspace': 'SHARE',
            'Escape': 'PS'
        };

        // å·²æŒ‰ä¸‹çš„é”®ï¼ˆç”¨äºé˜²æ­¢é‡å¤è§¦å‘ï¼‰
        const pressedKeys = new Set();

        // é”®ç›˜äº‹ä»¶å¤„ç†
        function handleKeyboardEvent(event, isKeyDown) {
            // å¦‚æœç„¦ç‚¹åœ¨è¾“å…¥æ¡†æˆ–æ–‡æœ¬åŒºåŸŸï¼Œä¸å¤„ç†é”®ç›˜äº‹ä»¶ï¼ˆé™¤äº† Escapeï¼‰
            const activeElement = document.activeElement;
            const isInputFocused = activeElement && (
                activeElement.tagName === 'INPUT' ||
                activeElement.tagName === 'TEXTAREA' ||
                activeElement.isContentEditable
            );

            // Escape é”®å§‹ç»ˆå¤„ç†
            if (event.key === 'Escape' || event.code === 'Escape') {
                if (isInputFocused) {
                    activeElement.blur();
                }
            } else if (isInputFocused) {
                // å…¶ä»–é”®åœ¨è¾“å…¥æ¡†ä¸­æ—¶ä¸å¤„ç†
                return;
            }

            // é˜²æ­¢é»˜è®¤è¡Œä¸ºï¼ˆæŸäº›é”®ï¼‰
            // âš ï¸ ä¿®å¤ï¼šä½¿ç”¨ let è€Œä¸æ˜¯ constï¼Œé¿å…åœ¨æŸäº›æƒ…å†µä¸‹å‡ºç°èµ‹å€¼é”™è¯¯
            let keyCode = event.code || event.key;
            if (keyboardMapping[keyCode]) {
                if (['Space', 'Tab', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(keyCode)) {
                    event.preventDefault();
                }
            }

            // å¤„ç†æŒ‰é”®
            let buttonName = keyboardMapping[keyCode];
            if (buttonName) {
                if (isKeyDown) {
                    // æŒ‰ä¸‹æ—¶åªè§¦å‘ä¸€æ¬¡
                    if (!pressedKeys.has(keyCode)) {
                        pressedKeys.add(keyCode);
                        
                        // é«˜äº®å¯¹åº”çš„æŒ‰é’®
                        const btn = document.querySelector(`.controller-btn[data-button="${buttonName}"]`);
                        if (btn) {
                            btn.style.opacity = '0.7';
                            btn.style.transform = 'scale(0.95)';
                        }
                        
                        // å‘é€æŒ‰ä¸‹äº‹ä»¶ï¼ˆé•¿æŒ‰æ¨¡å¼ï¼‰
                        log(`âŒ¨ï¸ é”®ç›˜æŒ‰ä¸‹: ${keyCode} -> ${buttonName} (é•¿æŒ‰æ¨¡å¼)`, 'info');
                        sendControllerButton(buttonName, 'press');
                    }
                } else {
                    // é‡Šæ”¾æ—¶ç§»é™¤æ ‡è®°
                    if (pressedKeys.has(keyCode)) {
                        pressedKeys.delete(keyCode);
                        
                        // æ¢å¤æŒ‰é’®æ ·å¼
                        const btn = document.querySelector(`.controller-btn[data-button="${buttonName}"]`);
                        if (btn) {
                            btn.style.opacity = '1';
                            btn.style.transform = '';
                        }
                        
                        // å‘é€é‡Šæ”¾äº‹ä»¶
                        log(`âŒ¨ï¸ é”®ç›˜é‡Šæ”¾: ${keyCode} -> ${buttonName}`, 'info');
                        sendControllerButton(buttonName, 'release');
                    }
                }
            }
        }

        // æ ‡è®°æ˜¯å¦å·²åˆå§‹åŒ–é”®ç›˜æ˜ å°„ï¼ˆé¿å…é‡å¤åˆå§‹åŒ–ï¼‰
        let keyboardMappingInitialized = false;

        // åˆå§‹åŒ–é”®ç›˜äº‹ä»¶ç›‘å¬
        function initKeyboardMapping() {
            // å¦‚æœå·²ç»åˆå§‹åŒ–ï¼Œè·³è¿‡
            if (keyboardMappingInitialized) {
                log('âš ï¸ é”®ç›˜æ˜ å°„å·²åˆå§‹åŒ–ï¼Œè·³è¿‡é‡å¤åˆå§‹åŒ–', 'warning');
                return;
            }
            
            try {
                // ç›‘å¬é”®ç›˜æŒ‰ä¸‹
                document.addEventListener('keydown', (event) => {
                    handleKeyboardEvent(event, true);
                }, false);

                // ç›‘å¬é”®ç›˜é‡Šæ”¾
                document.addEventListener('keyup', (event) => {
                    handleKeyboardEvent(event, false);
                }, false);

                // é¡µé¢å¤±å»ç„¦ç‚¹æ—¶æ¸…é™¤æ‰€æœ‰æŒ‰é”®çŠ¶æ€
                window.addEventListener('blur', () => {
                    // é‡Šæ”¾æ‰€æœ‰æŒ‰ä¸‹çš„æŒ‰é’®
                    pressedKeys.forEach(keyCode => {
                        const buttonName = keyboardMapping[keyCode];
                        if (buttonName) {
                            sendControllerButton(buttonName, 'release');
                        }
                    });
                    pressedKeys.clear();
                    
                    // é‡Šæ”¾æ‰€æœ‰é¼ æ ‡æŒ‰ä¸‹çš„æŒ‰é’®
                    pressedButtons.forEach((value, buttonName) => {
                        sendControllerButton(buttonName, 'release');
                    });
                    pressedButtons.clear();
                    
                    // æ¢å¤æ‰€æœ‰æŒ‰é’®æ ·å¼
                    document.querySelectorAll('.controller-btn').forEach(btn => {
                        btn.style.opacity = '1';
                        btn.style.transform = '';
                    });
                });

                keyboardMappingInitialized = true;
                log('âœ… é”®ç›˜æ˜ å°„å·²åˆå§‹åŒ–', 'success');
            } catch (error) {
                log(`âŒ åˆå§‹åŒ–é”®ç›˜æ˜ å°„å¤±è´¥: ${error.message}`, 'error');
                throw error;
            }
        }

        // é¡µé¢å¸è½½æ—¶æ¸…ç†
        window.addEventListener('beforeunload', () => {
            disconnect();
        });
    </script>
</body>
</html>

